{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/serenaantonetti/portfolio-2019/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _typedarrayPool = _interopRequireDefault(require(\"typedarray-pool\"));\n\nvar _ndarray = _interopRequireDefault(require(\"ndarray\"));\n\nvar _Uniform = _interopRequireDefault(require(\"./Uniform\"));\n\nvar _Bus = _interopRequireDefault(require(\"./Bus\"));\n\nvar _Shaders = _interopRequireWildcard(require(\"./Shaders\"));\n\nvar _invariantNoDependentsLoop = _interopRequireDefault(require(\"./helpers/invariantNoDependentsLoop\"));\n\nvar _genId = _interopRequireDefault(require(\"./genId\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst blendFuncAliases = {\n  zero: \"ZERO\",\n  one: \"ONE\",\n  \"src color\": \"SRC_COLOR\",\n  \"one minus src color\": \"ONE_MINUS_SRC_COLOR\",\n  \"src alpha\": \"SRC_ALPHA\",\n  \"one minus src alpha\": \"ONE_MINUS_SRC_ALPHA\",\n  \"dst color\": \"DST_COLOR\",\n  \"one minus dst color\": \"ONE_MINUS_DST_COLOR\",\n  \"dst alpha\": \"DST_ALPHA\",\n  \"one minus dst alpha\": \"ONE_MINUS_DST_ALPHA\",\n  \"constant color\": \"CONSTANT_COLOR\",\n  \"one minus constant color\": \"ONE_MINUS_CONSTANT_COLOR\",\n  \"constant alpha\": \"CONSTANT_ALPHA\",\n  \"one minus constant alpha\": \"ONE_MINUS_CONSTANT_ALPHA\",\n  \"src alpha saturate\": \"SRC_ALPHA_SATURATE\"\n};\n/**\n * The texture pixel interpolation mode.\n *\n * One of:\n * - `linear`\n * - `nearest`\n */\n\nconst isBackbuffer = obj => {\n  if (obj === \"Backbuffer\") {\n    console.warn('Backbuffer is deprecated, use Uniform.Backbuffer instead: `import {Uniform} from \"gl-react\"`');\n    return true;\n  }\n\n  return obj === _Uniform.default.Backbuffer;\n};\n\nconst isBackbufferFrom = obj => obj && typeof obj === \"object\" && obj.type === \"BackbufferFrom\";\n\nconst isTextureSizeGetter = obj => obj && typeof obj === \"object\" && obj.type === \"TextureSize\";\n\nconst nodeWidthHeight = ({\n  width,\n  height\n}, {\n  glSizable\n}) => {\n  if (width && height) return [width, height];\n\n  const _glSizable$getGLSize = glSizable.getGLSize(),\n        _glSizable$getGLSize2 = _slicedToArray(_glSizable$getGLSize, 2),\n        cw = _glSizable$getGLSize2[0],\n        ch = _glSizable$getGLSize2[1];\n\n  return [width || cw, height || ch];\n};\n\nconst mapBlendFunc = (gl, name) => {\n  // $FlowFixMe\n  if (name in gl) return gl[name];\n\n  if (name in blendFuncAliases) {\n    const id = blendFuncAliases[name]; // $FlowFixMe\n\n    if (id in gl) return gl[id];\n  }\n\n  console.warn(\"Invalid blendFunc. Got:\", name);\n};\n\nconst parseWrap = (gl, w) => {\n  switch (w) {\n    case \"clamp to edge\":\n      return gl.CLAMP_TO_EDGE;\n\n    case \"repeat\":\n      return gl.REPEAT;\n\n    case \"mirrored repeat\":\n      return gl.MIRRORED_REPEAT;\n\n    default:\n      console.warn(\"Invalid wrap. Got:\", w);\n      return gl.CLAMP_TO_EDGE;\n  }\n};\n\nconst mergeArrays = (a, b) => {\n  const t = [];\n  const length = Math.max(a.length, b.length);\n\n  for (let i = 0; i < length; i++) {\n    t[i] = b[i] || a[i];\n  }\n\n  return t;\n};\n\nconst parseInterpolation = (gl, i) => {\n  switch (i) {\n    case \"linear\":\n      return gl.LINEAR;\n\n    case \"nearest\":\n      return gl.NEAREST;\n\n    default:\n      console.warn(\"Invalid interpolation. Got:\", i);\n      return gl.LINEAR;\n  }\n}; // minimal version of gl-fbo\n\n\nconst createFBO = (gl, width, height) => {\n  var handle = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, handle);\n  var color = gl.createTexture();\n  if (!color) throw new Error(\"createTexture returned null\");\n  gl.bindTexture(gl.TEXTURE_2D, color);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, color, 0);\n  return {\n    handle,\n    color,\n    bind: () => {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, handle);\n      gl.viewport(0, 0, width, height);\n    },\n    syncSize: (w, h) => {\n      if (w !== width || h !== height) {\n        width = w;\n        height = h;\n        gl.bindTexture(gl.TEXTURE_2D, color);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      }\n    },\n    dispose: () => {\n      gl.deleteFramebuffer(handle);\n      gl.deleteTexture(color);\n    }\n  };\n};\n\nconst defaultTextureOptions = {\n  interpolation: \"linear\",\n  wrap: [\"clamp to edge\", \"clamp to edge\"]\n};\n\nconst applyTextureOptions = (gl, partialOpts) => {\n  const opts = _objectSpread({}, defaultTextureOptions, {}, partialOpts);\n\n  let filter = parseInterpolation(gl, opts.interpolation);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n  let wrapS, wrapT;\n\n  if (Array.isArray(opts.wrap)) {\n    if (opts.wrap.length !== 2) {\n      console.warn(\"textureOptions wrap: should be an array of 2 values. Got:\", opts.wrap);\n      wrapS = wrapT = gl.CLAMP_TO_EDGE;\n    } else {\n      wrapS = parseWrap(gl, opts.wrap[0]);\n      wrapT = parseWrap(gl, opts.wrap[1]);\n    }\n  } else {\n    wrapS = wrapT = parseWrap(gl, opts.wrap);\n  }\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n};\n\nconst NodePropTypes = {\n  shader: _propTypes.default.object.isRequired,\n  uniformsOptions: _propTypes.default.object,\n  uniforms: _propTypes.default.object,\n  ignoreUnusedUniforms: _propTypes.default.any,\n  sync: _propTypes.default.bool,\n  width: _propTypes.default.number,\n  height: _propTypes.default.number,\n  children: _propTypes.default.any,\n  backbuffering: _propTypes.default.bool,\n  blendFunc: _propTypes.default.object,\n  clear: _propTypes.default.object,\n  onDraw: _propTypes.default.func\n};\n/**\n * `<Node>` is the primitive that renders a shader program into a Framebuffer.\n * It can be composed with other `Node` via using a sampler2D uniforms.\n *\n * @prop {ShaderIdentifier} shader - created with `Shaders.create`\n * @prop {Uniforms} [uniforms] - uniform values that gets passed to the fragment shader.\n * @prop {Object} [uniformsOptions] - allows to configure things like interpolation of a sampler2D texture.\n * @prop {number} [width] - the width in in real pixels unit (unlike Surface, no pixel ratio)\n * @prop {number} [height] - the height in in real pixels unit (unlike Surface, no pixel ratio)\n * @prop {bool} [sync] - If true, a React update will always force a sync redraw of the Node framebuffer.\n * @prop {bool} [backbuffering] - enable the backbuffering that allows to use `Backbuffer` in uniforms to get the previous framebuffer texture state in the fragment shader.\n * @prop {BlendFuncSrcDst} [blendFunc] - configure the blending function to use\n * @prop {Clear} [clear] - configure the clear to use (color,...)\n * @prop {Function} [onDraw] - a callback called each time a draw was produced for this Node.\n * @prop {any} [children] - in advanced use-cases, you can render things like Bus or contents to be used by Node\n * @prop {any} [ignoreUnusedUniforms] - ignore all or some uniforms to be warned if they are not existing or used in the actual shader code (by default it's good for dev to warn them but they are usecase where it's not easy to know, like if the GLSL code come from the user). boolean to ignore all or whitelist array of uniforms name to ignore.\n * @example\n *  <Node shader={shaders.helloGL} />\n */\n\nclass Node extends _react.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"drawProps\", this.props);\n\n    _defineProperty(this, \"context\", void 0);\n\n    _defineProperty(this, \"framebuffer\", void 0);\n\n    _defineProperty(this, \"backbuffer\", void 0);\n\n    _defineProperty(this, \"_needsRedraw\", false);\n\n    _defineProperty(this, \"capturePixelsArray\", void 0);\n\n    _defineProperty(this, \"id\", (0, _genId.default)());\n\n    _defineProperty(this, \"uniformsBus\", {});\n\n    _defineProperty(this, \"dependencies\", []);\n\n    _defineProperty(this, \"dependents\", []);\n\n    _defineProperty(this, \"_resolveElement\", (uniform, value, index) => {\n      if (!_react.default.isValidElement(value)) {\n        if (typeof value === \"function\") {\n          value = value(this.redraw);\n\n          if (!_react.default.isValidElement(value)) {\n            return; // the function don't return an Element, skip\n          }\n        } else {\n            return; // the value isn't an Element, skip\n          }\n      }\n\n      return _react.default.createElement(_Bus.default, {\n        key: uniform + (index ? \".\" + index : \"\"),\n        uniform: uniform,\n        index: index\n      }, value);\n    });\n\n    _defineProperty(this, \"_renderUniformElement\", key => {\n      const uniforms = this.props.uniforms;\n      let value = uniforms[key];\n      return Array.isArray(value) ? value.map((v, i) => this._resolveElement(key, v, i)) : this._resolveElement(key, value, 0);\n    });\n\n    _defineProperty(this, \"redraw\", () => {\n      if (!this._needsRedraw) {\n        this._needsRedraw = true;\n        this.dependents.forEach(d => d.redraw());\n      }\n    });\n\n    _defineProperty(this, \"flush\", () => {\n      this.context.glSurface._draw();\n    });\n\n    _defineProperty(this, \"_latestShaderInfo\", void 0);\n\n    _defineProperty(this, \"_shader\", void 0);\n  }\n\n  getChildContext() {\n    return {\n      glParent: this,\n      glSizable: this\n    };\n  }\n\n  componentDidMount() {\n    const gl = this.context.glSurface.gl;\n    if (gl) this._prepareGLObjects(gl);\n\n    this.context.glParent._addGLNodeChild(this);\n\n    this.redraw();\n    if (this.props.sync) this.flush();\n  }\n\n  componentWillUnmount() {\n    const capturePixelsArray = this.capturePixelsArray;\n\n    this._destroyGLObjects();\n\n    if (capturePixelsArray) {\n      _typedarrayPool.default.freeUint8(capturePixelsArray);\n    }\n\n    this._needsRedraw = false;\n\n    this.context.glParent._removeGLNodeChild(this);\n\n    this.dependencies.forEach(d => d._removeDependent(this));\n  }\n\n  _syncNextDrawProps(nextProps, nextContext) {\n    const nextWidthHeight = nodeWidthHeight(nextProps, nextContext);\n\n    if (this.framebuffer) {\n      this.framebuffer.syncSize(...nextWidthHeight);\n    }\n\n    if (this.backbuffer) {\n      this.backbuffer.syncSize(...nextWidthHeight);\n    }\n\n    (0, _invariant.default)(nextProps.backbuffering === this.drawProps.backbuffering, \"Node backbuffering prop must not changed. (not yet supported)\");\n    this.drawProps = nextProps;\n  }\n\n  render() {\n    const _this$props = this.props,\n          children = _this$props.children,\n          uniforms = _this$props.uniforms;\n    const RenderLessElement = this.context.glSurface.RenderLessElement;\n    return _react.default.createElement(RenderLessElement, null, children, Object.keys(uniforms).map(this._renderUniformElement));\n  }\n\n  componentDidUpdate() {\n    this._syncNextDrawProps(this.props, this.context);\n\n    this.redraw();\n    if (this.props.sync) this.flush();\n  }\n\n  getGLShortName() {\n    const shader = this.drawProps.shader;\n    const shaderName = (0, _Shaders.isShaderIdentifier)(shader) ? // $FlowFixMe FIXME\n    _Shaders.default.getShortName(shader) : \"<inline>\";\n    return `Node(${shaderName})`;\n  }\n\n  getGLName() {\n    const shader = this.drawProps.shader;\n    const shaderName = (0, _Shaders.isShaderIdentifier)(shader) ? // $FlowFixMe FIXME\n    _Shaders.default.getName(shader) : \"<inline>\";\n    return `Node#${this.id}(${shaderName})`;\n  }\n\n  getGLSize() {\n    return nodeWidthHeight(this.drawProps, this.context);\n  }\n\n  getGLOutput() {\n    const framebuffer = this.framebuffer;\n    (0, _invariant.default)(framebuffer, \"Node#getGLOutput: framebuffer is not defined. It cannot be called on a root Node\");\n    return framebuffer.color;\n  }\n\n  getGLBackbufferOutput() {\n    const backbuffer = this.backbuffer;\n    (0, _invariant.default)(backbuffer, \"Node#getGLBackbufferOutput: backbuffer is not defined. Make sure `backbuffering` prop is defined\");\n    return backbuffer.color;\n  }\n  /**\n   * Imperatively set the props with a partial subset of props to apply.\n   * This is an escape hatch to perform a redraw with different props without having to trigger a new React draw. Only use it when reaching a performance bottleneck.\n   * NB: at any time, render() needs to consistently render the same props you set in setDrawProps to avoid any potential blink (if a React draw would occur).\n   * @param {Props} patch a subset of props to apply on top of the previous draw props.\n   */\n\n\n  setDrawProps(patch) {\n    // $FlowFixMe\n    const nextProps = _objectSpread({}, this.drawProps, {}, patch);\n\n    this._syncNextDrawProps(nextProps, this.context);\n\n    this.redraw();\n    if (nextProps.sync) this.flush();\n  }\n  /**\n   * Capture the node pixels.\n   * Without parameters, it will capture the full rectangle,\n   * otherwise you can provide (x, y) or (x, y, w, h) to provide a subset of this rectangle.\n   */\n\n\n  capture(x, y, w, h) {\n    const _this$getGLSize = this.getGLSize(),\n          _this$getGLSize2 = _slicedToArray(_this$getGLSize, 2),\n          width = _this$getGLSize2[0],\n          height = _this$getGLSize2[1];\n\n    const gl = this.context.glSurface.gl;\n    (0, _invariant.default)(gl, \"gl is no longer available\");\n    if (x === undefined) x = 0;\n    if (y === undefined) y = 0;\n    if (w === undefined) w = width - x;\n    if (h === undefined) h = height - y;\n    (0, _invariant.default)(x >= 0 && x + w <= width && y >= 0 && y + h <= height, \"capture(%s,%s,%s,%s): requested rectangle is out of bounds (%s,%s)\", x, y, w, h, width, height);\n    const size = w * h * 4;\n\n    const pixels = this._captureAlloc(size);\n\n    this._bind();\n\n    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    return (0, _ndarray.default)(pixels, [h, w, 4]).step(-1, 1, 1).transpose(1, 0, 2);\n  }\n  /**\n   * Schedule a redraw of this node and all dependent nodes.\n   *\n   * @function\n   */\n\n\n  _destroyGLObjects() {\n    const glSurface = this.context.glSurface;\n\n    if (glSurface.glIsAvailable()) {\n      // We should only dispose() if gl is still here.\n      // otherwise, GL should already have free resources.\n      // (also workaround for https://github.com/stackgl/headless-gl/issues/90)\n      const framebuffer = this.framebuffer,\n            backbuffer = this.backbuffer,\n            _shader = this._shader;\n\n      if (_shader) {\n        _shader.dispose();\n      }\n\n      if (framebuffer) {\n        framebuffer.dispose();\n      }\n\n      if (backbuffer) {\n        backbuffer.dispose();\n      }\n    }\n\n    delete this._shader;\n    delete this.framebuffer;\n    delete this.backbuffer;\n  }\n\n  _prepareGLObjects(gl) {\n    const _this$getGLSize3 = this.getGLSize(),\n          _this$getGLSize4 = _slicedToArray(_this$getGLSize3, 2),\n          width = _this$getGLSize4[0],\n          height = _this$getGLSize4[1];\n\n    const _this$context = this.context,\n          glParent = _this$context.glParent,\n          glSurface = _this$context.glSurface;\n\n    if (glParent === glSurface) {\n      // my parent IS the glSurface, should prevent from creating a FBO.\n      // when a FBO is not created, _draw() happens on the final Canvas (null fbo)\n      // NB we can just do this in WillMount because this context will not change.\n      (0, _invariant.default)(!this.drawProps.backbuffering, \"`backbuffering` is currently not supported for a Root Node. \" + \"Try to wrap %s in a <LinearCopy> or <NearestCopy>.\", this.getGLName());\n    } else {\n      const fbo = createFBO(gl, width, height);\n      this.framebuffer = fbo;\n\n      if (this.drawProps.backbuffering) {\n        const fbo = createFBO(gl, width, height);\n        this.backbuffer = fbo;\n      }\n    }\n  }\n\n  _onContextLost() {\n    this.dependencies.forEach(d => d._onContextLost());\n\n    this._destroyGLObjects();\n  }\n\n  _onContextRestored(gl) {\n    this._prepareGLObjects(gl);\n\n    this.dependencies.forEach(d => d._onContextRestored(gl));\n    this._needsRedraw = true;\n  }\n\n  _addGLNodeChild(node) {}\n\n  _removeGLNodeChild(node) {}\n\n  _addUniformBus(uniformBus, uniformName, index) {\n    const array = this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);\n    array[index] = uniformBus;\n  }\n\n  _removeUniformBus(uniformBus, uniformName, index) {\n    const array = this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);\n\n    if (array[index] === uniformBus) {\n      array[index] = null;\n    }\n  }\n\n  _addDependent(node) {\n    const i = this.dependents.indexOf(node);\n\n    if (i === -1) {\n      (0, _invariantNoDependentsLoop.default)(this, node);\n      this.dependents.push(node);\n    }\n  }\n\n  _removeDependent(node) {\n    const i = this.dependents.indexOf(node);\n\n    if (i !== -1) {\n      this.dependents.splice(i, 1);\n    }\n  }\n\n  _syncDependencies(newdeps) {\n    const olddeps = this.dependencies;\n    const additions = newdeps.filter(node => olddeps.indexOf(node) === -1);\n    const deletions = olddeps.filter(node => newdeps.indexOf(node) === -1);\n    additions.forEach(d => d._addDependent(this));\n    deletions.forEach(d => d._removeDependent(this));\n    this.dependencies = newdeps;\n    return [additions, deletions];\n  }\n\n  _bind() {\n    if (this.framebuffer) {\n      this.framebuffer.bind();\n    } else {\n      this.context.glSurface._bindRootNode();\n    }\n  }\n\n  _captureAlloc(size) {\n    let capturePixelsArray = this.capturePixelsArray;\n\n    if (capturePixelsArray && size !== capturePixelsArray.length) {\n      _typedarrayPool.default.freeUint8(capturePixelsArray);\n\n      capturePixelsArray = null;\n    }\n\n    const pixels = capturePixelsArray || _typedarrayPool.default.mallocUint8(size);\n\n    this.capturePixelsArray = pixels;\n    return pixels;\n  } // in case of inline shader, a Node currently hold a Node\n\n\n  _getShader(shaderProp) {\n    const glSurface = this.context.glSurface;\n    const nodeName = this.getGLName();\n    (0, _invariant.default)(shaderProp, nodeName + \": shader prop must be provided\");\n\n    if ((0, _Shaders.isShaderIdentifier)(shaderProp)) {\n      // $FlowFixMe\n      return glSurface._getShader(shaderProp);\n    }\n\n    const shaderInfo = (0, _Shaders.shaderDefinitionToShaderInfo)((0, _Shaders.ensureShaderDefinition)(shaderProp, \" in \" + nodeName));\n    const latestShaderInfo = this._latestShaderInfo;\n    let shader = this._shader;\n\n    if (!shader || !latestShaderInfo || !(0, _Shaders.shaderInfoEquals)(latestShaderInfo, shaderInfo)) {\n      if (shader) {\n        shader.dispose();\n        delete this._shader;\n      }\n\n      shader = glSurface._makeShader(shaderInfo);\n      this._latestShaderInfo = shaderInfo;\n      this._shader = shader;\n    }\n\n    return shader;\n  }\n\n  _draw() {\n    const glSurface = this.context.glSurface;\n    const gl = glSurface.gl;\n    const visitors = glSurface.getVisitors();\n    const nodeName = this.getGLName();\n\n    if (!gl || !this._needsRedraw) {\n      visitors.forEach(v => v.onNodeDrawSkipped(this));\n      return;\n    }\n\n    const _this$drawProps = this.drawProps,\n          backbuffering = _this$drawProps.backbuffering,\n          uniforms = _this$drawProps.uniforms,\n          uniformsOptions = _this$drawProps.uniformsOptions,\n          shaderProp = _this$drawProps.shader,\n          blendFunc = _this$drawProps.blendFunc,\n          clear = _this$drawProps.clear,\n          onDraw = _this$drawProps.onDraw,\n          ignoreUnusedUniforms = _this$drawProps.ignoreUnusedUniforms; //~ PREPARE phase\n\n    if (!this.framebuffer) {\n      const glSizable = this.context.glSizable;\n\n      const _glSizable$getGLSize3 = glSizable.getGLSize(),\n            _glSizable$getGLSize4 = _slicedToArray(_glSizable$getGLSize3, 2),\n            width = _glSizable$getGLSize4[0],\n            height = _glSizable$getGLSize4[1];\n\n      const _this$getGLSize5 = this.getGLSize(),\n            _this$getGLSize6 = _slicedToArray(_this$getGLSize5, 2),\n            nw = _this$getGLSize6[0],\n            nh = _this$getGLSize6[1];\n\n      (0, _invariant.default)(nw === width && nh === height, nodeName + \" is root but have overrided {width=%s,height=%s} which doesn't match Surface size {width=%s,height=%s}. \" + \"Try to wrap your Node in a <NearestCopy> or <LinearCopy>\", nw, nh, width, height);\n    }\n\n    const shader = this._getShader(shaderProp);\n\n    this._needsRedraw = false; // FIXME what's the correct position of this line?\n\n    const types = shader.types;\n    const glRedrawableDependencies = [];\n    const pendingTextures = [];\n    let units = 0;\n    const usedUniforms = Object.keys(types.uniforms);\n    const providedUniforms = Object.keys(uniforms);\n    const uniformsBus = this.uniformsBus;\n\n    for (let k in uniformsBus) {\n      if (!(k in uniforms)) {\n        providedUniforms.push(k);\n      }\n    }\n\n    const textureUnits = new Map();\n\n    const prepareTexture = (initialObj, uniformOptions, uniformKeyName) => {\n      let obj = initialObj,\n          dependency,\n          result;\n\n      if (typeof obj === \"function\") {\n        // texture uniform can be a function that resolves the object at draw time.\n        obj = obj(this.redraw);\n      }\n\n      if (!obj) {\n        if (obj === undefined) {\n          console.warn(`${nodeName}, uniform '${uniformKeyName}' is undefined.` + \"If you explicitely want to clear a texture, set it to null.\");\n        }\n      } else if (isBackbuffer(obj)) {\n        // maybe it's backbuffer?\n        if (!this.drawProps.backbuffering) {\n          console.warn(`${nodeName}, uniform ${uniformKeyName}: you must set \\`backbuffering\\` on Node when using Backbuffer`);\n        }\n\n        result = {\n          glNode: this,\n          glNodePickBackbuffer: true\n        };\n      } else if (isBackbufferFrom(obj)) {\n        // backbuffer of another node/bus\n        (0, _invariant.default)(typeof obj === \"object\", \"invalid backbufferFromNode. Got: %s\", obj);\n        let node = obj.node;\n\n        if (node instanceof _Bus.default) {\n          node = node.getGLRenderableNode();\n          (0, _invariant.default)(node, \"backbufferFromNode(bus) but bus.getGLRenderableNode() is %s\", node);\n        }\n\n        (0, _invariant.default)(node instanceof Node, \"invalid backbufferFromNode(obj): obj must be an instanceof Node or Bus. Got: %s\", obj);\n\n        if (!node.drawProps.backbuffering) {\n          console.warn(`${nodeName}, uniform ${uniformKeyName}: you must set \\`backbuffering\\` on the Node referenced in backbufferFrom(${node.getGLName()})`);\n        }\n\n        result = {\n          glNode: node,\n          glNodePickBackbuffer: true\n        };\n      } else if (obj instanceof Node) {\n        // maybe it's a Node?\n        dependency = obj;\n        result = {\n          glNode: obj\n        };\n      } else if (obj instanceof _Bus.default) {\n        // maybe it's a Bus?\n        // to a node?\n        const node = obj.getGLRenderableNode();\n\n        if (node) {\n          dependency = node;\n          result = {\n            glNode: node\n          };\n        } else {\n          // to a DOM/native element? (like <canvas>, <video>, ...)\n          dependency = obj;\n          const renderable = obj.getGLRenderableContent();\n\n          if (!renderable) {\n            console.warn(`${nodeName}, uniform ${uniformKeyName}: child is not renderable. Got:`, renderable);\n            result = {\n              directTexture: null\n            };\n          } else {\n            obj = renderable;\n          }\n        }\n      } // In any remaining cases, we are asking texture loaders\n      // to concretely resolve the Texture.\n\n\n      if (!result && obj) {\n        const _glSurface$_resolveTe = glSurface._resolveTextureLoader(obj),\n              loader = _glSurface$_resolveTe.loader,\n              input = _glSurface$_resolveTe.input;\n\n        if (!loader) {\n          console.warn(`${nodeName}, uniform ${uniformKeyName}: no loader found for value`, input, obj);\n        } else {\n          const t = loader.get(input);\n\n          if (t) {\n            loader.update(input);\n            result = {\n              directTexture: t.texture,\n              directTextureSize: [t.width, t.height]\n            };\n          } else {\n            // otherwise, we will have to load it and postpone the rendering.\n            const p = loader.load(input);\n            pendingTextures.push(p);\n          }\n        }\n      } // we also accumulate a dep, that will be used to build the gl graph.\n\n\n      if (dependency) glRedrawableDependencies.push(dependency);\n      const textureOptions = result ? uniformOptions : null;\n\n      const getMetaInfo = () => ({\n        initialObj,\n        obj,\n        dependency,\n        textureOptions\n      });\n\n      const getSize = () => {\n        const fallback = [2, 2];\n        return result ? \"directTextureSize\" in result ? result.directTextureSize : result.glNode ? result.glNode.getGLSize() : fallback : fallback;\n      };\n\n      const prepare = () => {\n        const texture = result && (result.directTexture || result.glNode && (result.glNodePickBackbuffer ? result.glNode.getGLBackbufferOutput() : result.glNode.getGLOutput())) || glSurface.getEmptyTexture();\n\n        if (textureUnits.has(texture)) {\n          // FIXME different uniform options on a same texture is not supported\n          return textureUnits.get(texture);\n        }\n\n        const value = units++;\n        gl.activeTexture(gl.TEXTURE0 + value);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        applyTextureOptions(gl, textureOptions);\n        textureUnits.set(texture, value);\n        return value;\n      };\n\n      return {\n        getMetaInfo,\n        getSize,\n        prepare\n      };\n    };\n\n    const prepareUniform = key => {\n      const uniformType = types.uniforms[key];\n\n      if (!uniformType) {\n        const ignoredWarn = ignoreUnusedUniforms === true || ignoreUnusedUniforms instanceof Array && ignoreUnusedUniforms.includes(key);\n\n        if (!ignoredWarn) {\n          console.warn(`${nodeName} uniform '${key}' is not declared, nor used, in your shader code`);\n        }\n\n        return {\n          key,\n          value: undefined\n        };\n      }\n\n      const uniformValue = uniforms[key];\n      usedUniforms.splice(usedUniforms.indexOf(key), 1);\n\n      if (uniformType === \"sampler2D\") {\n        const uniformBus = uniformsBus[key];\n\n        const _prepareTexture = prepareTexture(uniformBus && uniformBus[0] || uniformValue, uniformsOptions[key], key),\n              getMetaInfo = _prepareTexture.getMetaInfo,\n              prepare = _prepareTexture.prepare;\n\n        return {\n          key,\n          type: uniformType,\n          getMetaInfo,\n          prepare\n        };\n      } else if (uniformValue === _Uniform.default.Resolution) {\n        return {\n          key,\n          type: uniformType,\n          value: this.getGLSize()\n        };\n      } else if (isTextureSizeGetter(uniformValue)) {\n        (0, _invariant.default)(uniformValue && typeof uniformValue === \"object\", \"unexpected textureSize object. Got: %s\", uniformValue);\n\n        const _prepareTexture2 = prepareTexture(uniformValue.obj, null, key),\n              getSize = _prepareTexture2.getSize;\n\n        const size = getSize();\n\n        if (!size) {\n          console.warn(`${nodeName}, uniform ${key}: texture size is undetermined`);\n        }\n\n        const value = uniformValue.ratio ? size ? size[0] / size[1] : 1 : size || [0, 0];\n        return {\n          key,\n          type: uniformType,\n          value\n        };\n      } else if (Array.isArray(uniformType) && uniformType[0] === \"sampler2D\") {\n        let values;\n        const uniformBus = uniformsBus[key];\n        const v = mergeArrays(Array.isArray(uniformValue) ? uniformValue : [], Array.isArray(uniformBus) ? uniformBus : []);\n\n        if (!v.length) {\n          console.warn(`${nodeName}, uniform '${key}' should be an array of textures.`);\n          values = uniformType.map(() => null);\n        } else if (v.length !== uniformType.length) {\n          console.warn(`${nodeName}, uniform '${key}' should be an array of exactly ${uniformType.length} textures (not ${v.length}).`);\n          values = uniformType.map(() => null);\n        } else {\n          values = v;\n        }\n\n        const uniformOptions = uniformsOptions[key]; // TODO support array of options as well\n\n        const all = values.map((value, i) => prepareTexture(value, uniformOptions, key + \"[\" + i + \"]\"));\n        return {\n          key,\n          type: uniformType,\n          getMetaInfo: () => all.reduce((acc, o) => acc.concat(o.getMetaInfo()), []),\n          prepare: () => all.map(o => o.prepare())\n        };\n      } else {\n        if (uniformValue === undefined) {\n          console.warn(`${nodeName}, uniform '${key}' is undefined.`);\n        }\n\n        return {\n          key,\n          type: uniformType,\n          value: uniformValue\n        };\n      }\n    };\n\n    const preparedUniforms = providedUniforms.map(prepareUniform);\n\n    if (usedUniforms.length !== 0) {\n      console.warn(nodeName + \": Missing uniforms: \" + usedUniforms.map(u => `'${u}'`).join(\", \") + \"\\n\" + \"all uniforms must be provided \" + \"because implementations might share and reuse a Shader Program\");\n    } // if some textures are not ready, we freeze the rendering so it doesn't blink\n\n\n    if (pendingTextures.length > 0) {\n      Promise.all(pendingTextures).then(this.redraw); // ^ FIXME \"cancel\" this promise if we ever come back in _draw()\n\n      visitors.forEach(v => v.onNodeDrawSkipped(this));\n      return;\n    } //~ the draw will happen, there is no more interruption cases.\n\n\n    visitors.forEach(v => v.onNodeDrawStart(this));\n\n    const _this$_syncDependenci = this._syncDependencies(glRedrawableDependencies),\n          _this$_syncDependenci2 = _slicedToArray(_this$_syncDependenci, 2),\n          additions = _this$_syncDependenci2[0],\n          deletions = _this$_syncDependenci2[1];\n\n    visitors.forEach(v => v.onNodeSyncDeps(this, additions, deletions));\n\n    if (backbuffering) {\n      // swap framebuffer and backbuffer\n      const backbuffer = this.backbuffer,\n            framebuffer = this.framebuffer;\n      this.backbuffer = framebuffer;\n\n      if (backbuffer) {\n        this.framebuffer = backbuffer;\n      }\n    } //~ DRAW dependencies step\n\n\n    const drawDep = d => d._draw();\n\n    this.dependencies.forEach(drawDep); //~ DRAW this node step\n\n    visitors.forEach(v => v.onNodeDraw(this, preparedUniforms));\n    shader.bind();\n\n    this._bind();\n\n    preparedUniforms.forEach(obj => {\n      const value = obj.prepare ? obj.prepare() : obj.value;\n\n      if (value !== undefined) {\n        shader.uniforms[obj.key] = value;\n      }\n    });\n\n    if (blendFunc) {\n      const src = mapBlendFunc(gl, blendFunc.src);\n      const dst = mapBlendFunc(gl, blendFunc.dst);\n      if (src && dst) gl.blendFunc(src, dst);\n    }\n\n    if (clear) {\n      gl.clearColor(...clear.color);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n    if (onDraw) onDraw();\n    visitors.forEach(v => v.onNodeDrawEnd(this));\n  }\n\n}\n\nexports.default = Node;\n\n_defineProperty(Node, \"propTypes\", NodePropTypes);\n\n_defineProperty(Node, \"defaultProps\", {\n  uniformsOptions: {},\n  uniforms: {},\n  blendFunc: {\n    // FIXME should this actually just be null by default? opt-in?\n    src: \"src alpha\",\n    dst: \"one minus src alpha\"\n  },\n  clear: {\n    color: [0, 0, 0, 0]\n  }\n});\n\n_defineProperty(Node, \"contextTypes\", {\n  glParent: _propTypes.default.object.isRequired,\n  glSurface: _propTypes.default.object.isRequired,\n  glSizable: _propTypes.default.object.isRequired\n});\n\n_defineProperty(Node, \"childContextTypes\", {\n  glParent: _propTypes.default.object.isRequired,\n  glSizable: _propTypes.default.object.isRequired\n});","map":{"version":3,"sources":["../src/Node.js"],"names":["blendFuncAliases","zero","one","isBackbuffer","obj","console","Uniform","isBackbufferFrom","isTextureSizeGetter","nodeWidthHeight","height","glSizable","width","mapBlendFunc","name","gl","id","parseWrap","mergeArrays","t","length","Math","a","b","i","parseInterpolation","createFBO","handle","color","bind","syncSize","w","h","dispose","defaultTextureOptions","interpolation","wrap","applyTextureOptions","opts","filter","Array","wrapS","wrapT","NodePropTypes","shader","PropTypes","uniformsOptions","uniforms","ignoreUnusedUniforms","sync","children","backbuffering","blendFunc","clear","onDraw","func","Node","Component","src","dst","glParent","glSurface","isRequired","getChildContext","componentDidMount","componentWillUnmount","capturePixelsArray","pool","d","_syncNextDrawProps","nextWidthHeight","nextProps","React","value","uniform","index","key","render","RenderLessElement","Object","componentDidUpdate","getGLShortName","shaderName","Shaders","getGLName","getGLSize","getGLOutput","framebuffer","getGLBackbufferOutput","backbuffer","setDrawProps","capture","x","y","size","pixels","_destroyGLObjects","_shader","_prepareGLObjects","fbo","_onContextLost","_onContextRestored","_addGLNodeChild","_removeGLNodeChild","_addUniformBus","array","_removeUniformBus","_addDependent","_removeDependent","_syncDependencies","olddeps","additions","newdeps","node","deletions","_bind","_captureAlloc","_getShader","nodeName","shaderInfo","latestShaderInfo","_draw","visitors","v","nw","nh","types","glRedrawableDependencies","pendingTextures","units","usedUniforms","providedUniforms","uniformsBus","k","textureUnits","prepareTexture","uniformKeyName","result","glNode","glNodePickBackbuffer","Bus","dependency","renderable","directTexture","input","loader","directTextureSize","p","textureOptions","getMetaInfo","getSize","fallback","prepare","texture","prepareUniform","uniformType","ignoredWarn","undefined","uniformValue","uniformBus","type","values","uniformOptions","all","acc","o","preparedUniforms","u","Promise","drawDep"],"mappings":"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","sourcesContent":["//@flow\nimport invariant from \"invariant\";\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport pool from \"typedarray-pool\";\nimport ndarray from \"ndarray\";\nimport Uniform from \"./Uniform\";\nimport Bus from \"./Bus\";\nimport Shaders, {\n  isShaderIdentifier,\n  ensureShaderDefinition,\n  shaderDefinitionToShaderInfo,\n  shaderInfoEquals\n} from \"./Shaders\";\nimport invariantNoDependentsLoop from \"./helpers/invariantNoDependentsLoop\";\nimport genId from \"./genId\";\nimport type { Shader } from \"gl-shader\";\nimport type { NDArray } from \"ndarray\";\nimport type { ShaderIdentifier, ShaderInfo, ShaderDefinition } from \"./Shaders\";\nimport type { Surface, SurfaceContext } from \"./createSurface\";\n\nconst blendFuncAliases = {\n  zero: \"ZERO\",\n  one: \"ONE\",\n  \"src color\": \"SRC_COLOR\",\n  \"one minus src color\": \"ONE_MINUS_SRC_COLOR\",\n  \"src alpha\": \"SRC_ALPHA\",\n  \"one minus src alpha\": \"ONE_MINUS_SRC_ALPHA\",\n  \"dst color\": \"DST_COLOR\",\n  \"one minus dst color\": \"ONE_MINUS_DST_COLOR\",\n  \"dst alpha\": \"DST_ALPHA\",\n  \"one minus dst alpha\": \"ONE_MINUS_DST_ALPHA\",\n  \"constant color\": \"CONSTANT_COLOR\",\n  \"one minus constant color\": \"ONE_MINUS_CONSTANT_COLOR\",\n  \"constant alpha\": \"CONSTANT_ALPHA\",\n  \"one minus constant alpha\": \"ONE_MINUS_CONSTANT_ALPHA\",\n  \"src alpha saturate\": \"SRC_ALPHA_SATURATE\"\n};\n\n/**\n * The texture pixel interpolation mode.\n *\n * One of:\n * - `linear`\n * - `nearest`\n */\ntype Interpolation = \"linear\" | \"nearest\";\n\n/**\n * A texture wrap mode define how the texture lookup repeat over edges.\n *\n * One of:\n * - `clamp to edge`\n * - `repeat`\n * - `mirrored repeat`\n */\ntype WrapMode = \"clamp to edge\" | \"repeat\" | \"mirrored repeat\";\n\n/**\n * Options on a texture.\n * - interpolation define how the pixel lookup get mapped to screen.\n * - wrap define how the edge lookup behaves. It can be either a [x,y] wrap or a wrap value for both.\n */\ntype TextureOptions = {\n  interpolation: Interpolation,\n  wrap: [WrapMode, WrapMode] | WrapMode\n};\n\n/**\n * The GL blending function.\n *\n * One of:\n * - `zero`\n * - `one`\n * - `src color`\n * - `one minus src color`\n * - `src alpha`\n * - `one minus src alpha`\n * - `dst color`\n * - `one minus dst color`\n * - `dst alpha`\n * - `one minus dst alpha`\n * - `constant color`\n * - `one minus constant color`\n * - `constant alpha`\n * - `one minus constant alpha`\n * - `src alpha saturate`\n */\ntype BlendFunc = $Keys<typeof blendFuncAliases>;\n\n/**\n *\n */\ntype BlendFuncSrcDst = {|\n  src: BlendFunc,\n  dst: BlendFunc\n|};\n\n/**\n * Array of 4 numbers. Useful to represent colors. *[ r, g, b, a ]*\n */\ntype Vec4 = [number, number, number, number];\n\n/**\n * The GL clear mode.\n */\ntype Clear = {|\n  color: Vec4\n|};\n\n/**\n * Uniforms is an map object from uniform name to a value.\n *\n * **The library support numerous uniform types via different formats.\n * Let's describe them:**\n *\n * ### int or float\n *\n * a JavaScript number\n *\n * ### bool\n *\n * a JavaScript Boolean\n *\n * ### int[], float[], bool[] arrays\n *\n * an array of the number (0/1 for bool can be used as well as bools)\n *\n * ### vec2, vec3, vec4\n *\n * an array of number, of size respectively 2, 3 and 4.\n *\n * > same is available for ivec* variants.\n *\n * ### mat2, mat3, mat4\n *\n * Similarly to vectorial types, you can pass an array of numbers.\n * For matrix, you actually define them in a flatten way (not arrays of arrays).\n *\n * ### sampler2D type (aka texture)\n *\n * The library support numerous and extensible uniform value format.\n *\n * **FIXME: to be documented.**\n *\n * ### struct types\n *\n * Consider it unsupported even though it *might* work since gl-react is based on `gl-shader`.\n *\n */\ntype Uniforms = {\n  [_: string]: mixed\n};\n\ntype UniformsOptions = {\n  [_: string]: ?$Shape<TextureOptions>\n};\n\ntype Props = {|\n  shader: ShaderIdentifier | ShaderDefinition,\n  uniformsOptions: UniformsOptions,\n  uniforms: Uniforms,\n  ignoreUnusedUniforms?: Array<string> | boolean,\n  sync?: boolean,\n  width?: number,\n  height?: number,\n  children?: any,\n  backbuffering?: boolean,\n  blendFunc: BlendFuncSrcDst,\n  clear: ?Clear,\n  onDraw?: () => void\n|};\n\n// not sure why, but we must define this for Flow to properly type check\ntype DefaultProps = {\n  uniformsOptions: UniformsOptions,\n  uniforms: Uniforms,\n  blendFunc: BlendFuncSrcDst,\n  clear: ?Clear\n};\n\ntype AsyncMixed = (redraw?: () => void) => mixed;\n\nconst isBackbuffer = (obj: *) => {\n  if (obj === \"Backbuffer\") {\n    console.warn(\n      'Backbuffer is deprecated, use Uniform.Backbuffer instead: `import {Uniform} from \"gl-react\"`'\n    );\n    return true;\n  }\n  return obj === Uniform.Backbuffer;\n};\n\nconst isBackbufferFrom = (obj: *) =>\n  obj && typeof obj === \"object\" && obj.type === \"BackbufferFrom\";\n\nconst isTextureSizeGetter = (obj: *) =>\n  obj && typeof obj === \"object\" && obj.type === \"TextureSize\";\n\nconst nodeWidthHeight = (\n  { width, height }: Props,\n  { glSizable }: SurfaceContext\n): [number, number] => {\n  if (width && height) return [width, height];\n  const [cw, ch] = glSizable.getGLSize();\n  return [width || cw, height || ch];\n};\n\nconst mapBlendFunc = (gl: WebGLRenderingContext, name: BlendFunc): ?number => {\n  // $FlowFixMe\n  if (name in gl) return gl[name];\n  if (name in blendFuncAliases) {\n    const id = blendFuncAliases[name];\n    // $FlowFixMe\n    if (id in gl) return gl[id];\n  }\n  console.warn(\"Invalid blendFunc. Got:\", name);\n};\n\nconst parseWrap = (gl: WebGLRenderingContext, w: string): number => {\n  switch (w) {\n    case \"clamp to edge\":\n      return gl.CLAMP_TO_EDGE;\n    case \"repeat\":\n      return gl.REPEAT;\n    case \"mirrored repeat\":\n      return gl.MIRRORED_REPEAT;\n    default:\n      console.warn(\"Invalid wrap. Got:\", w);\n      return gl.CLAMP_TO_EDGE;\n  }\n};\n\nconst mergeArrays = (a: Array<*>, b: Array<*>): Array<*> => {\n  const t = [];\n  const length = Math.max(a.length, b.length);\n  for (let i = 0; i < length; i++) {\n    t[i] = b[i] || a[i];\n  }\n  return t;\n};\n\nconst parseInterpolation = (gl: WebGLRenderingContext, i: string): number => {\n  switch (i) {\n    case \"linear\":\n      return gl.LINEAR;\n    case \"nearest\":\n      return gl.NEAREST;\n    default:\n      console.warn(\"Invalid interpolation. Got:\", i);\n      return gl.LINEAR;\n  }\n};\n\ntype Framebuffer = {\n  handle: WebGLFramebuffer,\n  color: WebGLTexture,\n  bind: () => void,\n  dispose: () => void,\n  syncSize: (w: number, h: number) => void\n};\n\n// minimal version of gl-fbo\nconst createFBO = (\n  gl: WebGLRenderingContext,\n  width: number,\n  height: number\n): Framebuffer => {\n  var handle = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, handle);\n  var color = gl.createTexture();\n  if (!color) throw new Error(\"createTexture returned null\");\n  gl.bindTexture(gl.TEXTURE_2D, color);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    gl.RGBA,\n    width,\n    height,\n    0,\n    gl.RGBA,\n    gl.UNSIGNED_BYTE,\n    null\n  );\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    color,\n    0\n  );\n  return {\n    handle,\n    color,\n    bind: () => {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, handle);\n      gl.viewport(0, 0, width, height);\n    },\n    syncSize: (w: number, h: number) => {\n      if (w !== width || h !== height) {\n        width = w;\n        height = h;\n        gl.bindTexture(gl.TEXTURE_2D, color);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          gl.RGBA,\n          w,\n          h,\n          0,\n          gl.RGBA,\n          gl.UNSIGNED_BYTE,\n          null\n        );\n      }\n    },\n    dispose: () => {\n      gl.deleteFramebuffer(handle);\n      gl.deleteTexture(color);\n    }\n  };\n};\n\nconst defaultTextureOptions: TextureOptions = {\n  interpolation: \"linear\",\n  wrap: [\"clamp to edge\", \"clamp to edge\"]\n};\n\nconst applyTextureOptions = (\n  gl: WebGLRenderingContext,\n  partialOpts: ?$Shape<TextureOptions>\n) => {\n  const opts: TextureOptions = { ...defaultTextureOptions, ...partialOpts };\n  let filter = parseInterpolation(gl, opts.interpolation);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n  let wrapS, wrapT;\n  if (Array.isArray(opts.wrap)) {\n    if (opts.wrap.length !== 2) {\n      console.warn(\n        \"textureOptions wrap: should be an array of 2 values. Got:\",\n        opts.wrap\n      );\n      wrapS = wrapT = gl.CLAMP_TO_EDGE;\n    } else {\n      wrapS = parseWrap(gl, opts.wrap[0]);\n      wrapT = parseWrap(gl, opts.wrap[1]);\n    }\n  } else {\n    wrapS = wrapT = parseWrap(gl, opts.wrap);\n  }\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n};\n\nconst NodePropTypes = {\n  shader: PropTypes.object.isRequired,\n  uniformsOptions: PropTypes.object,\n  uniforms: PropTypes.object,\n  ignoreUnusedUniforms: PropTypes.any,\n  sync: PropTypes.bool,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  children: PropTypes.any,\n  backbuffering: PropTypes.bool,\n  blendFunc: PropTypes.object,\n  clear: PropTypes.object,\n  onDraw: PropTypes.func\n};\n\n/**\n * `<Node>` is the primitive that renders a shader program into a Framebuffer.\n * It can be composed with other `Node` via using a sampler2D uniforms.\n *\n * @prop {ShaderIdentifier} shader - created with `Shaders.create`\n * @prop {Uniforms} [uniforms] - uniform values that gets passed to the fragment shader.\n * @prop {Object} [uniformsOptions] - allows to configure things like interpolation of a sampler2D texture.\n * @prop {number} [width] - the width in in real pixels unit (unlike Surface, no pixel ratio)\n * @prop {number} [height] - the height in in real pixels unit (unlike Surface, no pixel ratio)\n * @prop {bool} [sync] - If true, a React update will always force a sync redraw of the Node framebuffer.\n * @prop {bool} [backbuffering] - enable the backbuffering that allows to use `Backbuffer` in uniforms to get the previous framebuffer texture state in the fragment shader.\n * @prop {BlendFuncSrcDst} [blendFunc] - configure the blending function to use\n * @prop {Clear} [clear] - configure the clear to use (color,...)\n * @prop {Function} [onDraw] - a callback called each time a draw was produced for this Node.\n * @prop {any} [children] - in advanced use-cases, you can render things like Bus or contents to be used by Node\n * @prop {any} [ignoreUnusedUniforms] - ignore all or some uniforms to be warned if they are not existing or used in the actual shader code (by default it's good for dev to warn them but they are usecase where it's not easy to know, like if the GLSL code come from the user). boolean to ignore all or whitelist array of uniforms name to ignore.\n * @example\n *  <Node shader={shaders.helloGL} />\n */\nexport default class Node extends Component<Props, *> {\n  drawProps: Props = this.props;\n  context: SurfaceContext;\n  framebuffer: ?Framebuffer;\n  backbuffer: ?Framebuffer;\n  _needsRedraw: boolean = false;\n  capturePixelsArray: ?Uint8Array;\n  id: number = genId();\n  uniformsBus: { [key: string]: Array<?Bus> } = {};\n  dependencies: Array<Node | Bus> = []; // Node this instance depends on\n  dependents: Array<Node | Surface> = []; // Node/Surface that depends on this instance\n\n  static propTypes = NodePropTypes;\n\n  static defaultProps: DefaultProps = {\n    uniformsOptions: {},\n    uniforms: {},\n    blendFunc: {\n      // FIXME should this actually just be null by default? opt-in?\n      src: \"src alpha\",\n      dst: \"one minus src alpha\"\n    },\n    clear: {\n      color: [0, 0, 0, 0]\n    }\n  };\n\n  static contextTypes = {\n    glParent: PropTypes.object.isRequired,\n    glSurface: PropTypes.object.isRequired,\n    glSizable: PropTypes.object.isRequired\n  };\n\n  static childContextTypes = {\n    glParent: PropTypes.object.isRequired,\n    glSizable: PropTypes.object.isRequired\n  };\n\n  getChildContext() {\n    return {\n      glParent: this,\n      glSizable: this\n    };\n  }\n\n  componentDidMount() {\n    const {\n      glSurface: { gl }\n    } = this.context;\n    if (gl) this._prepareGLObjects(gl);\n    this.context.glParent._addGLNodeChild(this);\n    this.redraw();\n    if (this.props.sync) this.flush();\n  }\n\n  componentWillUnmount() {\n    const { capturePixelsArray } = this;\n    this._destroyGLObjects();\n    if (capturePixelsArray) {\n      pool.freeUint8(capturePixelsArray);\n    }\n    this._needsRedraw = false;\n    this.context.glParent._removeGLNodeChild(this);\n    this.dependencies.forEach(d => d._removeDependent(this));\n  }\n\n  _syncNextDrawProps(nextProps: Props, nextContext: *) {\n    const nextWidthHeight = nodeWidthHeight(nextProps, nextContext);\n    if (this.framebuffer) {\n      this.framebuffer.syncSize(...nextWidthHeight);\n    }\n    if (this.backbuffer) {\n      this.backbuffer.syncSize(...nextWidthHeight);\n    }\n    invariant(\n      nextProps.backbuffering === this.drawProps.backbuffering,\n      \"Node backbuffering prop must not changed. (not yet supported)\"\n    );\n    this.drawProps = nextProps;\n  }\n\n  _resolveElement = (\n    uniform: string,\n    value: mixed,\n    index: number\n  ): ?React$Element<*> => {\n    if (!React.isValidElement(value)) {\n      if (typeof value === \"function\") {\n        value = (value: AsyncMixed)(this.redraw);\n        if (!React.isValidElement(value)) {\n          return; // the function don't return an Element, skip\n        }\n      } else {\n        return; // the value isn't an Element, skip\n      }\n    }\n    return (\n      <Bus\n        key={uniform + (index ? \".\" + index : \"\")}\n        uniform={uniform}\n        index={index}\n      >\n        {value}\n      </Bus>\n    );\n  };\n\n  _renderUniformElement = (key: string) => {\n    const { uniforms } = this.props;\n    let value = uniforms[key];\n    return Array.isArray(value)\n      ? value.map((v, i) => this._resolveElement(key, v, i))\n      : this._resolveElement(key, value, 0);\n  };\n\n  render() {\n    const { children, uniforms } = this.props;\n    const {\n      glSurface: { RenderLessElement }\n    } = this.context;\n    return (\n      <RenderLessElement>\n        {children}\n        {Object.keys(uniforms).map(this._renderUniformElement)}\n      </RenderLessElement>\n    );\n  }\n\n  componentDidUpdate() {\n    this._syncNextDrawProps(this.props, this.context);\n    this.redraw();\n    if (this.props.sync) this.flush();\n  }\n\n  getGLShortName(): string {\n    const { shader } = this.drawProps;\n    const shaderName = isShaderIdentifier(shader)\n      ? // $FlowFixMe FIXME\n        Shaders.getShortName(shader)\n      : \"<inline>\";\n    return `Node(${shaderName})`;\n  }\n\n  getGLName(): string {\n    const { shader } = this.drawProps;\n    const shaderName = isShaderIdentifier(shader)\n      ? // $FlowFixMe FIXME\n        Shaders.getName(shader)\n      : \"<inline>\";\n    return `Node#${this.id}(${shaderName})`;\n  }\n\n  getGLSize(): [number, number] {\n    return nodeWidthHeight(this.drawProps, this.context);\n  }\n\n  getGLOutput(): WebGLTexture {\n    const { framebuffer } = this;\n    invariant(\n      framebuffer,\n      \"Node#getGLOutput: framebuffer is not defined. It cannot be called on a root Node\"\n    );\n    return framebuffer.color;\n  }\n\n  getGLBackbufferOutput(): WebGLTexture {\n    const { backbuffer } = this;\n    invariant(\n      backbuffer,\n      \"Node#getGLBackbufferOutput: backbuffer is not defined. Make sure `backbuffering` prop is defined\"\n    );\n    return backbuffer.color;\n  }\n\n  /**\n   * Imperatively set the props with a partial subset of props to apply.\n   * This is an escape hatch to perform a redraw with different props without having to trigger a new React draw. Only use it when reaching a performance bottleneck.\n   * NB: at any time, render() needs to consistently render the same props you set in setDrawProps to avoid any potential blink (if a React draw would occur).\n   * @param {Props} patch a subset of props to apply on top of the previous draw props.\n   */\n  setDrawProps(patch: $Shape<Props>) {\n    // $FlowFixMe\n    const nextProps: Props = {\n      ...this.drawProps,\n      ...patch\n    };\n    this._syncNextDrawProps(nextProps, this.context);\n    this.redraw();\n    if (nextProps.sync) this.flush();\n  }\n\n  /**\n   * Capture the node pixels.\n   * Without parameters, it will capture the full rectangle,\n   * otherwise you can provide (x, y) or (x, y, w, h) to provide a subset of this rectangle.\n   */\n  capture(x?: number, y?: number, w?: number, h?: number): NDArray {\n    const [width, height] = this.getGLSize();\n    const { gl } = this.context.glSurface;\n    invariant(gl, \"gl is no longer available\");\n    if (x === undefined) x = 0;\n    if (y === undefined) y = 0;\n    if (w === undefined) w = width - x;\n    if (h === undefined) h = height - y;\n    invariant(\n      x >= 0 && x + w <= width && y >= 0 && y + h <= height,\n      \"capture(%s,%s,%s,%s): requested rectangle is out of bounds (%s,%s)\",\n      x,\n      y,\n      w,\n      h,\n      width,\n      height\n    );\n    const size = w * h * 4;\n    const pixels: Uint8Array = this._captureAlloc(size);\n    this._bind();\n    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    return ndarray(pixels, [h, w, 4])\n      .step(-1, 1, 1)\n      .transpose(1, 0, 2);\n  }\n\n  /**\n   * Schedule a redraw of this node and all dependent nodes.\n   *\n   * @function\n   */\n  redraw = (): void => {\n    if (!this._needsRedraw) {\n      this._needsRedraw = true;\n      this.dependents.forEach(d => d.redraw());\n    }\n  };\n\n  /**\n   * Force the redraw (if any) to happen now, synchronously.\n   *\n   * @function\n   */\n  flush = (): void => {\n    this.context.glSurface._draw();\n  };\n\n  _destroyGLObjects(): void {\n    const { glSurface } = this.context;\n    if (glSurface.glIsAvailable()) {\n      // We should only dispose() if gl is still here.\n      // otherwise, GL should already have free resources.\n      // (also workaround for https://github.com/stackgl/headless-gl/issues/90)\n      const { framebuffer, backbuffer, _shader } = this;\n      if (_shader) {\n        _shader.dispose();\n      }\n      if (framebuffer) {\n        framebuffer.dispose();\n      }\n      if (backbuffer) {\n        backbuffer.dispose();\n      }\n    }\n    delete this._shader;\n    delete this.framebuffer;\n    delete this.backbuffer;\n  }\n\n  _prepareGLObjects(gl: WebGLRenderingContext): void {\n    const [width, height] = this.getGLSize();\n    const { glParent, glSurface } = this.context;\n    if (glParent === glSurface) {\n      // my parent IS the glSurface, should prevent from creating a FBO.\n      // when a FBO is not created, _draw() happens on the final Canvas (null fbo)\n      // NB we can just do this in WillMount because this context will not change.\n      invariant(\n        !this.drawProps.backbuffering,\n        \"`backbuffering` is currently not supported for a Root Node. \" +\n          \"Try to wrap %s in a <LinearCopy> or <NearestCopy>.\",\n        this.getGLName()\n      );\n    } else {\n      const fbo = createFBO(gl, width, height);\n      this.framebuffer = fbo;\n      if (this.drawProps.backbuffering) {\n        const fbo = createFBO(gl, width, height);\n        this.backbuffer = fbo;\n      }\n    }\n  }\n\n  _onContextLost(): void {\n    this.dependencies.forEach(d => d._onContextLost());\n    this._destroyGLObjects();\n  }\n\n  _onContextRestored(gl: WebGLRenderingContext): void {\n    this._prepareGLObjects(gl);\n    this.dependencies.forEach(d => d._onContextRestored(gl));\n    this._needsRedraw = true;\n  }\n\n  _addGLNodeChild(node: Node) {}\n  _removeGLNodeChild(node: Node) {}\n\n  _addUniformBus(uniformBus: Bus, uniformName: string, index: number): void {\n    const array =\n      this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);\n    array[index] = uniformBus;\n  }\n\n  _removeUniformBus(uniformBus: Bus, uniformName: string, index: number): void {\n    const array =\n      this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);\n    if (array[index] === uniformBus) {\n      array[index] = null;\n    }\n  }\n\n  _addDependent(node: Node | Surface): void {\n    const i = this.dependents.indexOf(node);\n    if (i === -1) {\n      invariantNoDependentsLoop(this, node);\n      this.dependents.push(node);\n    }\n  }\n\n  _removeDependent(node: Node | Surface): void {\n    const i = this.dependents.indexOf(node);\n    if (i !== -1) {\n      this.dependents.splice(i, 1);\n    }\n  }\n\n  _syncDependencies(\n    newdeps: Array<Node | Bus>\n  ): [Array<Bus | Node>, Array<Bus | Node>] {\n    const olddeps = this.dependencies;\n    const additions = newdeps.filter(node => olddeps.indexOf(node) === -1);\n    const deletions = olddeps.filter(node => newdeps.indexOf(node) === -1);\n    additions.forEach(d => d._addDependent(this));\n    deletions.forEach(d => d._removeDependent(this));\n    this.dependencies = newdeps;\n    return [additions, deletions];\n  }\n\n  _bind(): void {\n    if (this.framebuffer) {\n      this.framebuffer.bind();\n    } else {\n      this.context.glSurface._bindRootNode();\n    }\n  }\n\n  _captureAlloc(size: number): Uint8Array {\n    let { capturePixelsArray } = this;\n    if (capturePixelsArray && size !== capturePixelsArray.length) {\n      pool.freeUint8(capturePixelsArray);\n      capturePixelsArray = null;\n    }\n    const pixels: Uint8Array = capturePixelsArray || pool.mallocUint8(size);\n    this.capturePixelsArray = pixels;\n    return pixels;\n  }\n\n  _latestShaderInfo: ?ShaderInfo;\n  _shader: ?Shader; // in case of inline shader, a Node currently hold a Node\n\n  _getShader(shaderProp: mixed): Shader {\n    const { glSurface } = this.context;\n    const nodeName = this.getGLName();\n    invariant(shaderProp, nodeName + \": shader prop must be provided\");\n    if (isShaderIdentifier(shaderProp)) {\n      // $FlowFixMe\n      return glSurface._getShader(shaderProp);\n    }\n\n    const shaderInfo = shaderDefinitionToShaderInfo(\n      ensureShaderDefinition(shaderProp, \" in \" + nodeName)\n    );\n    const latestShaderInfo = this._latestShaderInfo;\n    let shader = this._shader;\n    if (\n      !shader ||\n      !latestShaderInfo ||\n      !shaderInfoEquals(latestShaderInfo, shaderInfo)\n    ) {\n      if (shader) {\n        shader.dispose();\n        delete this._shader;\n      }\n      shader = glSurface._makeShader(shaderInfo);\n      this._latestShaderInfo = shaderInfo;\n      this._shader = shader;\n    }\n    return shader;\n  }\n\n  _draw(): void {\n    const { glSurface } = this.context;\n    const { gl } = glSurface;\n    const visitors = glSurface.getVisitors();\n    const nodeName = this.getGLName();\n    if (!gl || !this._needsRedraw) {\n      visitors.forEach(v => v.onNodeDrawSkipped(this));\n      return;\n    }\n\n    const {\n      backbuffering,\n      uniforms,\n      uniformsOptions,\n      shader: shaderProp,\n      blendFunc,\n      clear,\n      onDraw,\n      ignoreUnusedUniforms\n    } = this.drawProps;\n\n    //~ PREPARE phase\n\n    if (!this.framebuffer) {\n      const { glSizable } = this.context;\n      const [width, height] = glSizable.getGLSize();\n      const [nw, nh] = this.getGLSize();\n      invariant(\n        nw === width && nh === height,\n        nodeName +\n          \" is root but have overrided {width=%s,height=%s} which doesn't match Surface size {width=%s,height=%s}. \" +\n          \"Try to wrap your Node in a <NearestCopy> or <LinearCopy>\",\n        nw,\n        nh,\n        width,\n        height\n      );\n    }\n\n    const shader = this._getShader(shaderProp);\n\n    this._needsRedraw = false; // FIXME what's the correct position of this line?\n\n    const { types } = shader;\n    const glRedrawableDependencies: Array<Node | Bus> = [];\n    const pendingTextures: Array<*> = [];\n    let units = 0;\n    const usedUniforms = Object.keys(types.uniforms);\n    const providedUniforms = Object.keys(uniforms);\n    const { uniformsBus } = this;\n    for (let k in uniformsBus) {\n      if (!(k in uniforms)) {\n        providedUniforms.push(k);\n      }\n    }\n    const textureUnits: Map<WebGLTexture, number> = new Map();\n\n    const prepareTexture = (\n      initialObj: mixed,\n      uniformOptions: ?$Shape<TextureOptions>,\n      uniformKeyName: string\n    ) => {\n      let obj = initialObj,\n        dependency: ?(Node | Bus),\n        result: ?{\n          directTexture?: ?WebGLTexture,\n          directTextureSize?: ?[number, number],\n          glNode?: Node,\n          glNodePickBackbuffer?: boolean\n        };\n\n      if (typeof obj === \"function\") {\n        // texture uniform can be a function that resolves the object at draw time.\n        obj = (obj: AsyncMixed)(this.redraw);\n      }\n\n      if (!obj) {\n        if (obj === undefined) {\n          console.warn(\n            `${nodeName}, uniform '${uniformKeyName}' is undefined.` +\n              \"If you explicitely want to clear a texture, set it to null.\"\n          );\n        }\n      } else if (isBackbuffer(obj)) {\n        // maybe it's backbuffer?\n        if (!this.drawProps.backbuffering) {\n          console.warn(\n            `${nodeName}, uniform ${uniformKeyName}: you must set \\`backbuffering\\` on Node when using Backbuffer`\n          );\n        }\n        result = { glNode: this, glNodePickBackbuffer: true };\n      } else if (isBackbufferFrom(obj)) {\n        // backbuffer of another node/bus\n        invariant(\n          typeof obj === \"object\",\n          \"invalid backbufferFromNode. Got: %s\",\n          obj\n        );\n        let node = obj.node;\n        if (node instanceof Bus) {\n          node = node.getGLRenderableNode();\n          invariant(\n            node,\n            \"backbufferFromNode(bus) but bus.getGLRenderableNode() is %s\",\n            node\n          );\n        }\n        invariant(\n          node instanceof Node,\n          \"invalid backbufferFromNode(obj): obj must be an instanceof Node or Bus. Got: %s\",\n          obj\n        );\n        if (!node.drawProps.backbuffering) {\n          console.warn(\n            `${nodeName}, uniform ${uniformKeyName}: you must set \\`backbuffering\\` on the Node referenced in backbufferFrom(${node.getGLName()})`\n          );\n        }\n        result = { glNode: node, glNodePickBackbuffer: true };\n      } else if (obj instanceof Node) {\n        // maybe it's a Node?\n        dependency = obj;\n        result = { glNode: obj };\n      } else if (obj instanceof Bus) {\n        // maybe it's a Bus?\n        // to a node?\n        const node = obj.getGLRenderableNode();\n        if (node) {\n          dependency = node;\n          result = { glNode: node };\n        } else {\n          // to a DOM/native element? (like <canvas>, <video>, ...)\n          dependency = obj;\n          const renderable: ?Element = obj.getGLRenderableContent();\n          if (!renderable) {\n            console.warn(\n              `${nodeName}, uniform ${uniformKeyName}: child is not renderable. Got:`,\n              renderable\n            );\n            result = { directTexture: null };\n          } else {\n            obj = renderable;\n          }\n        }\n      }\n\n      // In any remaining cases, we are asking texture loaders\n      // to concretely resolve the Texture.\n      if (!result && obj) {\n        const { loader, input } = glSurface._resolveTextureLoader(obj);\n        if (!loader) {\n          console.warn(\n            `${nodeName}, uniform ${uniformKeyName}: no loader found for value`,\n            input,\n            obj\n          );\n        } else {\n          const t = loader.get(input);\n          if (t) {\n            loader.update(input);\n            result = {\n              directTexture: t.texture,\n              directTextureSize: [t.width, t.height]\n            };\n          } else {\n            // otherwise, we will have to load it and postpone the rendering.\n            const p = loader.load(input);\n            pendingTextures.push(p);\n          }\n        }\n      }\n\n      // we also accumulate a dep, that will be used to build the gl graph.\n      if (dependency) glRedrawableDependencies.push(dependency);\n\n      const textureOptions = result ? uniformOptions : null;\n      const getMetaInfo = () => ({\n        initialObj,\n        obj,\n        dependency,\n        textureOptions\n      });\n      const getSize = (): ?[number, number] => {\n        const fallback = [2, 2];\n        return result\n          ? \"directTextureSize\" in result\n            ? result.directTextureSize\n            : result.glNode\n            ? result.glNode.getGLSize()\n            : fallback\n          : fallback;\n      };\n      const prepare = () => {\n        const texture: WebGLTexture =\n          (result &&\n            (result.directTexture ||\n              (result.glNode &&\n                (result.glNodePickBackbuffer\n                  ? result.glNode.getGLBackbufferOutput()\n                  : result.glNode.getGLOutput())))) ||\n          glSurface.getEmptyTexture();\n        if (textureUnits.has(texture)) {\n          // FIXME different uniform options on a same texture is not supported\n          return textureUnits.get(texture);\n        }\n        const value = units++;\n        gl.activeTexture(gl.TEXTURE0 + value);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        applyTextureOptions(gl, textureOptions);\n        textureUnits.set(texture, value);\n        return value;\n      };\n      return {\n        getMetaInfo,\n        getSize,\n        prepare\n      };\n    };\n\n    const prepareUniform = key => {\n      const uniformType = types.uniforms[key];\n      if (!uniformType) {\n        const ignoredWarn =\n          ignoreUnusedUniforms === true ||\n          (ignoreUnusedUniforms instanceof Array &&\n            ignoreUnusedUniforms.includes(key));\n        if (!ignoredWarn) {\n          console.warn(\n            `${nodeName} uniform '${key}' is not declared, nor used, in your shader code`\n          );\n        }\n        return { key, value: undefined };\n      }\n      const uniformValue = uniforms[key];\n      usedUniforms.splice(usedUniforms.indexOf(key), 1);\n\n      if (uniformType === \"sampler2D\") {\n        const uniformBus = uniformsBus[key];\n        const { getMetaInfo, prepare } = prepareTexture(\n          (uniformBus && uniformBus[0]) || uniformValue,\n          uniformsOptions[key],\n          key\n        );\n        return {\n          key,\n          type: uniformType,\n          getMetaInfo,\n          prepare\n        };\n      } else if (uniformValue === Uniform.Resolution) {\n        return {\n          key,\n          type: uniformType,\n          value: this.getGLSize()\n        };\n      } else if (isTextureSizeGetter(uniformValue)) {\n        invariant(\n          uniformValue && typeof uniformValue === \"object\",\n          \"unexpected textureSize object. Got: %s\",\n          uniformValue\n        );\n        const { getSize } = prepareTexture(uniformValue.obj, null, key);\n        const size = getSize();\n        if (!size) {\n          console.warn(\n            `${nodeName}, uniform ${key}: texture size is undetermined`\n          );\n        }\n        const value = uniformValue.ratio\n          ? size\n            ? size[0] / size[1]\n            : 1\n          : size || [0, 0];\n        return {\n          key,\n          type: uniformType,\n          value\n        };\n      } else if (Array.isArray(uniformType) && uniformType[0] === \"sampler2D\") {\n        let values;\n        const uniformBus = uniformsBus[key];\n        const v = mergeArrays(\n          Array.isArray(uniformValue) ? uniformValue : [],\n          Array.isArray(uniformBus) ? uniformBus : []\n        );\n        if (!v.length) {\n          console.warn(\n            `${nodeName}, uniform '${key}' should be an array of textures.`\n          );\n          values = uniformType.map(() => null);\n        } else if (v.length !== uniformType.length) {\n          console.warn(\n            `${nodeName}, uniform '${key}' should be an array of exactly ${uniformType.length} textures (not ${v.length}).`\n          );\n          values = uniformType.map(() => null);\n        } else {\n          values = v;\n        }\n\n        const uniformOptions = uniformsOptions[key]; // TODO support array of options as well\n        const all = values.map((value, i) =>\n          prepareTexture(value, uniformOptions, key + \"[\" + i + \"]\")\n        );\n\n        return {\n          key,\n          type: uniformType,\n          getMetaInfo: () =>\n            all.reduce((acc, o) => acc.concat(o.getMetaInfo()), []),\n          prepare: () => all.map(o => o.prepare())\n        };\n      } else {\n        if (uniformValue === undefined) {\n          console.warn(`${nodeName}, uniform '${key}' is undefined.`);\n        }\n        return {\n          key,\n          type: uniformType,\n          value: uniformValue\n        };\n      }\n    };\n    const preparedUniforms = providedUniforms.map(prepareUniform);\n\n    if (usedUniforms.length !== 0) {\n      console.warn(\n        nodeName +\n          \": Missing uniforms: \" +\n          usedUniforms.map(u => `'${u}'`).join(\", \") +\n          \"\\n\" +\n          \"all uniforms must be provided \" +\n          \"because implementations might share and reuse a Shader Program\"\n      );\n    }\n\n    // if some textures are not ready, we freeze the rendering so it doesn't blink\n    if (pendingTextures.length > 0) {\n      Promise.all(pendingTextures).then(this.redraw);\n      // ^ FIXME \"cancel\" this promise if we ever come back in _draw()\n      visitors.forEach(v => v.onNodeDrawSkipped(this));\n      return;\n    }\n\n    //~ the draw will happen, there is no more interruption cases.\n    visitors.forEach(v => v.onNodeDrawStart(this));\n\n    const [additions, deletions] = this._syncDependencies(\n      glRedrawableDependencies\n    );\n    visitors.forEach(v => v.onNodeSyncDeps(this, additions, deletions));\n\n    if (backbuffering) {\n      // swap framebuffer and backbuffer\n      const { backbuffer, framebuffer } = this;\n      this.backbuffer = framebuffer;\n      if (backbuffer) {\n        this.framebuffer = backbuffer;\n      }\n    }\n\n    //~ DRAW dependencies step\n    const drawDep = d => d._draw();\n    this.dependencies.forEach(drawDep);\n\n    //~ DRAW this node step\n\n    visitors.forEach(v => v.onNodeDraw(this, preparedUniforms));\n\n    shader.bind();\n    this._bind();\n    preparedUniforms.forEach(obj => {\n      const value = obj.prepare ? obj.prepare() : obj.value;\n      if (value !== undefined) {\n        shader.uniforms[obj.key] = value;\n      }\n    });\n\n    if (blendFunc) {\n      const src = mapBlendFunc(gl, blendFunc.src);\n      const dst = mapBlendFunc(gl, blendFunc.dst);\n      if (src && dst) gl.blendFunc(src, dst);\n    }\n\n    if (clear) {\n      gl.clearColor(...clear.color);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n    if (onDraw) onDraw();\n\n    visitors.forEach(v => v.onNodeDrawEnd(this));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}