{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _WebGLTextureLoader = _interopRequireDefault(require(\"./WebGLTextureLoader\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass WebGLTextureLoaderSyncHashCache extends _WebGLTextureLoader.default {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"results\", new Map());\n\n    _defineProperty(this, \"promises\", new Map());\n\n    _defineProperty(this, \"_disposed\", false);\n  } // return a unique representation of the input (typically a hash, or anything that can be used as ref identifier)\n\n\n  inputHash(input) {\n    return \"\";\n  } // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load\n\n\n  getNoCache(input) {\n    throw new Error(\"getNoCache must be implemented\");\n  }\n\n  dispose() {\n    const gl = this.gl,\n          results = this.results,\n          promises = this.promises;\n    results.forEach(r => {\n      this.disposeTexture(r.texture);\n    });\n    results.clear();\n    promises.clear();\n    this._disposed = true;\n  }\n\n  disposeTexture(texture) {\n    this.gl.deleteTexture(texture);\n  }\n\n  get(input) {\n    const hash = this.inputHash(input);\n    const result = this.results.get(hash);\n    if (result) return result;\n    const freshResult = this.getNoCache(input);\n    this.results.set(hash, freshResult);\n    return freshResult;\n  } // load() implementation is a dumb fallback on get() but still need to save the promise to guarantee idempotent\n\n\n  load(input) {\n    const hash = this.inputHash(input);\n    const existing = this.promises.get(hash);\n    if (existing) return existing;\n    const promise = Promise.resolve(this.get(input));\n    this.promises.set(hash, promise);\n    return promise;\n  }\n\n}\n\nvar _default = WebGLTextureLoaderSyncHashCache;\nexports.default = _default;","map":{"version":3,"sources":["../src/WebGLTextureLoaderSyncHashCache.js"],"names":["WebGLTextureLoader","inputHash","getNoCache","dispose","promises","results","r","disposeTexture","get","hash","result","freshResult","load","existing","promise","Promise","WebGLTextureLoaderSyncHashCache"],"mappings":";;;;;;;AACA,IAAA,mBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,sBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;AAGA,MAAA,+BAAA,SAAiDA,mBAAAA,CAAjD,OAAA,CAAuE;AAAA,EAAA,WAAA,CAAA,GAAA,IAAA,EAAA;AAAA,UAAA,GAAA,IAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,SAAA,EAUnC,IAVmC,GAUnC,EAVmC,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,UAAA,EAWzB,IAXyB,GAWzB,EAXyB,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,EAAA,KAAA,CAAA;AAAA,GAAA,CACrE;;;AACAC,EAAAA,SAAS,CAAA,KAAA,EAAW;AAClB,WAAA,EAAA;AAHmE,GAAA,CAKrE;;;AACAC,EAAAA,UAAU,CAAA,KAAA,EAA2B;AACnC,UAAM,IAAA,KAAA,CAAN,gCAAM,CAAN;AACD;;AAMDC,EAAAA,OAAO,GAAG;AAAA,UACF,EADE,GACR,IADQ,CACF,EADE;AAAA,UACF,OADE,GACR,IADQ,CACF,OADE;AAAA,UACaC,QADb,GACR,IADQ,CACaA,QADb;AAERC,IAAAA,OAAO,CAAPA,OAAAA,CAAgBC,CAAC,IAAI;AACnB,WAAA,cAAA,CAAoBA,CAAC,CAArB,OAAA;AADFD,KAAAA;AAGAA,IAAAA,OAAO,CAAPA,KAAAA;AACAD,IAAAA,QAAQ,CAARA,KAAAA;AACA,SAAA,SAAA,GAAA,IAAA;AACD;;AAEDG,EAAAA,cAAc,CAAA,OAAA,EAAwB;AACpC,SAAA,EAAA,CAAA,aAAA,CAAA,OAAA;AACD;;AAEDC,EAAAA,GAAG,CAAA,KAAA,EAAW;AACZ,UAAMC,IAAI,GAAG,KAAA,SAAA,CAAb,KAAa,CAAb;AACA,UAAMC,MAAM,GAAG,KAAA,OAAA,CAAA,GAAA,CAAf,IAAe,CAAf;AACA,QAAA,MAAA,EAAY,OAAA,MAAA;AACZ,UAAMC,WAAW,GAAG,KAAA,UAAA,CAApB,KAAoB,CAApB;AACA,SAAA,OAAA,CAAA,GAAA,CAAA,IAAA,EAAA,WAAA;AACA,WAAA,WAAA;AAlCmE,GAAA,CAqCrE;;;AACAC,EAAAA,IAAI,CAAA,KAAA,EAAW;AACb,UAAMH,IAAI,GAAG,KAAA,SAAA,CAAb,KAAa,CAAb;AACA,UAAMI,QAAQ,GAAG,KAAA,QAAA,CAAA,GAAA,CAAjB,IAAiB,CAAjB;AACA,QAAA,QAAA,EAAc,OAAA,QAAA;AACd,UAAMC,OAAO,GAAGC,OAAO,CAAPA,OAAAA,CAAgB,KAAA,GAAA,CAAhC,KAAgC,CAAhBA,CAAhB;AACA,SAAA,QAAA,CAAA,GAAA,CAAA,IAAA,EAAA,OAAA;AACA,WAAA,OAAA;AACD;;AA7CoE;;eAgDxDC,+B","sourcesContent":["//@flow\nimport WebGLTextureLoader from \"./WebGLTextureLoader\";\nimport type { TextureAndSize } from \"./WebGLTextureLoader\";\n\nclass WebGLTextureLoaderSyncHashCache<T> extends WebGLTextureLoader<T> {\n  // return a unique representation of the input (typically a hash, or anything that can be used as ref identifier)\n  inputHash(input: T) {\n    return \"\";\n  }\n  // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load\n  getNoCache(input: T): TextureAndSize {\n    throw new Error(\"getNoCache must be implemented\");\n  }\n\n  results: Map<*, TextureAndSize> = new Map();\n  promises: Map<*, Promise<TextureAndSize>> = new Map();\n\n  _disposed = false;\n  dispose() {\n    const { gl, results, promises } = this;\n    results.forEach(r => {\n      this.disposeTexture(r.texture);\n    });\n    results.clear();\n    promises.clear();\n    this._disposed = true;\n  }\n\n  disposeTexture(texture: WebGLTexture) {\n    this.gl.deleteTexture(texture);\n  }\n\n  get(input: T) {\n    const hash = this.inputHash(input);\n    const result = this.results.get(hash);\n    if (result) return result;\n    const freshResult = this.getNoCache(input);\n    this.results.set(hash, freshResult);\n    return freshResult;\n  }\n\n  // load() implementation is a dumb fallback on get() but still need to save the promise to guarantee idempotent\n  load(input: T) {\n    const hash = this.inputHash(input);\n    const existing = this.promises.get(hash);\n    if (existing) return existing;\n    const promise = Promise.resolve(this.get(input));\n    this.promises.set(hash, promise);\n    return promise;\n  }\n}\n\nexport default WebGLTextureLoaderSyncHashCache;\n"]},"metadata":{},"sourceType":"script"}