{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/serenaantonetti/portfolio-2019/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _webgltextureLoader = require(\"webgltexture-loader\");\n\nvar _drawNDArrayTexture = _interopRequireDefault(require(\"./drawNDArrayTexture\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass NDArrayTextureLoader extends _webgltextureLoader.WebGLTextureLoaderSyncHashCache {\n  constructor(gl) {\n    super(gl);\n\n    _defineProperty(this, \"floatSupported\", void 0);\n\n    this.floatSupported = gl.getExtension(\"OES_texture_float\") && gl.getExtension(\"OES_texture_float_linear\");\n  }\n\n  canLoad(obj) {\n    return obj.shape && obj.data && obj.stride;\n  }\n\n  inputHash(input) {\n    return input;\n  }\n\n  getNoCache(input) {\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    const _input$shape = _slicedToArray(input.shape, 2),\n          width = _input$shape[0],\n          height = _input$shape[1];\n\n    (0, _drawNDArrayTexture.default)(gl, texture, input, this.floatSupported);\n    return {\n      texture,\n      width,\n      height\n    };\n  }\n\n  update(input) {\n    // For now we assume the NDArray always change & need a redraw but we might try to only update if changes later\n    const gl = this.gl;\n\n    const _this$get = this.get(input),\n          texture = _this$get.texture;\n\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    (0, _drawNDArrayTexture.default)(gl, texture, input, this.floatSupported);\n  }\n\n}\n\n_webgltextureLoader.globalRegistry.add(NDArrayTextureLoader);\n\nvar _default = NDArrayTextureLoader;\nexports.default = _default;","map":{"version":3,"sources":["../src/NDArrayTextureLoader.js"],"names":["WebGLTextureLoaderSyncHashCache","constructor","gl","canLoad","obj","inputHash","getNoCache","texture","input","height","update","globalRegistry","NDArrayTextureLoader"],"mappings":";;;;;;;;;AACA,IAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAKA,IAAA,mBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,sBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAA,oBAAA,SAAmCA,mBAAAA,CAAnC,+BAAA,CAA4E;AAE1EC,EAAAA,WAAW,CAAA,EAAA,EAAQ;AACjB,UAAA,EAAA;;AADiB,IAAA,eAAA,CAAA,IAAA,EAAA,gBAAA,EAAA,KAAA,CAAA,CAAA;;AAEjB,SAAA,cAAA,GACEC,EAAE,CAAFA,YAAAA,CAAAA,mBAAAA,KACAA,EAAE,CAAFA,YAAAA,CAFF,0BAEEA,CAFF;AAGD;;AAEDC,EAAAA,OAAO,CAAA,GAAA,EAAW;AAChB,WAAOC,GAAG,CAAHA,KAAAA,IAAaA,GAAG,CAAhBA,IAAAA,IAAyBA,GAAG,CAAnC,MAAA;AACD;;AAEDC,EAAAA,SAAS,CAAA,KAAA,EAAiB;AACxB,WAAA,KAAA;AACD;;AAEDC,EAAAA,UAAU,CAAA,KAAA,EAAiB;AAAA,UACjBJ,EADiB,GACzB,IADyB,CACjBA,EADiB;AAEzB,UAAMK,OAAO,GAAGL,EAAE,CAAlB,aAAgBA,EAAhB;AACAA,IAAAA,EAAE,CAAFA,WAAAA,CAAeA,EAAE,CAAjBA,UAAAA,EAAAA,OAAAA;;AAHyB,wCAIDM,KAAK,CAA7B,KAJyB;AAAA,UAInB,KAJmB;AAAA,UAInB,MAJmB;;AAKzB,KAAA,GAAA,mBAAA,CAAA,OAAA,EAAA,EAAA,EAAA,OAAA,EAAA,KAAA,EAAuC,KAAvC,cAAA;AACA,WAAO;AAAA,MAAA,OAAA;AAAA,MAAA,KAAA;AAAkBC,MAAAA;AAAlB,KAAP;AACD;;AAEDC,EAAAA,MAAM,CAAA,KAAA,EAAiB;AACrB;AADqB,UAEbR,EAFa,GAErB,IAFqB,CAEbA,EAFa;;AAAA,sBAGD,KAAA,GAAA,CAApB,KAAoB,CAHC;AAAA,UAGbK,OAHa,aAGbA,OAHa;;AAIrBL,IAAAA,EAAE,CAAFA,WAAAA,CAAeA,EAAE,CAAjBA,UAAAA,EAAAA,OAAAA;AACA,KAAA,GAAA,mBAAA,CAAA,OAAA,EAAA,EAAA,EAAA,OAAA,EAAA,KAAA,EAAuC,KAAvC,cAAA;AACD;;AAhCyE;;AAmC5ES,mBAAAA,CAAAA,cAAAA,CAAAA,GAAAA,CAAAA,oBAAAA;;eAEeC,oB","sourcesContent":["//@flow\nimport {\n  WebGLTextureLoaderSyncHashCache,\n  globalRegistry\n} from \"webgltexture-loader\";\nimport type { NDArray } from \"ndarray\";\nimport drawNDArrayTexture from \"./drawNDArrayTexture\";\n\nclass NDArrayTextureLoader extends WebGLTextureLoaderSyncHashCache<NDArray> {\n  floatSupported: boolean;\n  constructor(gl: *) {\n    super(gl);\n    this.floatSupported =\n      gl.getExtension(\"OES_texture_float\") &&\n      gl.getExtension(\"OES_texture_float_linear\");\n  }\n\n  canLoad(obj: any) {\n    return obj.shape && obj.data && obj.stride;\n  }\n\n  inputHash(input: NDArray) {\n    return input;\n  }\n\n  getNoCache(input: NDArray) {\n    const { gl } = this;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const [width, height] = input.shape;\n    drawNDArrayTexture(gl, texture, input, this.floatSupported);\n    return { texture, width, height };\n  }\n\n  update(input: NDArray) {\n    // For now we assume the NDArray always change & need a redraw but we might try to only update if changes later\n    const { gl } = this;\n    const { texture } = this.get(input);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    drawNDArrayTexture(gl, texture, input, this.floatSupported);\n  }\n}\n\nglobalRegistry.add(NDArrayTextureLoader);\n\nexport default NDArrayTextureLoader;\n"]},"metadata":{},"sourceType":"script"}