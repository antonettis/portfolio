{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _WebGLTextureLoader = _interopRequireDefault(require(\"./WebGLTextureLoader\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst neverEnding = new Promise(() => {});\n/**\n * A cache implementation of WebGLTextureLoader with a input hash function\n */\n\nclass WebGLTextureLoaderAsyncHashCache extends _WebGLTextureLoader.default {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"disposes\", new Map());\n\n    _defineProperty(this, \"inputs\", new Map());\n\n    _defineProperty(this, \"promises\", new Map());\n\n    _defineProperty(this, \"results\", new Map());\n\n    _defineProperty(this, \"_disposed\", false);\n  }\n\n  inputHash(input) {\n    return \"\";\n  } // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load\n\n\n  loadNoCache(input) {\n    return {\n      promise: Promise.reject(new Error(\"loadNoCache is not implemented\")),\n      dispose: () => {}\n    };\n  }\n\n  dispose() {\n    const gl = this.gl,\n          promises = this.promises,\n          results = this.results,\n          inputs = this.inputs,\n          disposes = this.disposes;\n    disposes.forEach(d => d());\n    results.forEach(result => {\n      this.disposeTexture(result.texture);\n    });\n    promises.clear();\n    results.clear();\n    inputs.clear();\n    disposes.clear();\n    this._disposed = true;\n  }\n\n  disposeTexture(texture) {\n    this.gl.deleteTexture(texture);\n  }\n\n  load(input) {\n    const hash = this.inputHash(input);\n    const maybePromise = this.promises.get(hash);\n    if (maybePromise) return maybePromise;\n    const d = this.loadNoCache(input);\n    this.disposes.set(hash, d.dispose);\n    const promise = d.promise.then(result => {\n      if (!this.promises.has(hash)) {\n        return neverEnding;\n      }\n\n      this.disposes.delete(hash);\n      this.results.set(hash, result);\n      return result;\n    });\n    this.promises.set(hash, promise);\n    return promise;\n  }\n\n  get(input) {\n    return this.results.get(this.inputHash(input));\n  }\n\n  cancelLoad(input) {\n    const hash = this.inputHash(input);\n    this.promises.delete(hash);\n    const dispose = this.disposes.get(hash);\n\n    if (dispose) {\n      dispose();\n      this.disposes.delete(hash);\n    }\n  }\n\n}\n\nvar _default = WebGLTextureLoaderAsyncHashCache;\nexports.default = _default;","map":{"version":3,"sources":["../src/WebGLTextureLoaderAsyncHashCache.js"],"names":["neverEnding","WebGLTextureLoader","inputHash","loadNoCache","promise","Promise","dispose","disposes","d","results","result","promises","inputs","disposeTexture","load","hash","maybePromise","get","cancelLoad","WebGLTextureLoaderAsyncHashCache"],"mappings":"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","sourcesContent":["//@flow\nimport WebGLTextureLoader from \"./WebGLTextureLoader\";\nimport type { TextureAndSize } from \"./WebGLTextureLoader\";\n\nconst neverEnding = new Promise(() => {});\n\n/**\n * A cache implementation of WebGLTextureLoader with a input hash function\n */\nclass WebGLTextureLoaderAsyncHashCache<T> extends WebGLTextureLoader<T> {\n  inputHash(input: T) {\n    return \"\";\n  }\n  // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load\n  loadNoCache(\n    input: T\n  ): { promise: Promise<TextureAndSize>, dispose: Function } {\n    return {\n      promise: Promise.reject(new Error(\"loadNoCache is not implemented\")),\n      dispose: () => {}\n    };\n  }\n\n  disposes: Map<*, Function> = new Map();\n  inputs: Map<*, T> = new Map();\n  promises: Map<*, Promise<TextureAndSize>> = new Map();\n  results: Map<*, TextureAndSize> = new Map();\n\n  _disposed = false;\n  dispose() {\n    const { gl, promises, results, inputs, disposes } = this;\n    disposes.forEach(d => d());\n    results.forEach(result => {\n      this.disposeTexture(result.texture);\n    });\n    promises.clear();\n    results.clear();\n    inputs.clear();\n    disposes.clear();\n    this._disposed = true;\n  }\n\n  disposeTexture(texture: WebGLTexture) {\n    this.gl.deleteTexture(texture);\n  }\n\n  load(input: T) {\n    const hash = this.inputHash(input);\n    const maybePromise = this.promises.get(hash);\n    if (maybePromise) return maybePromise;\n    const d = this.loadNoCache(input);\n    this.disposes.set(hash, d.dispose);\n    const promise = d.promise.then(result => {\n      if (!this.promises.has(hash)) {\n        return neverEnding;\n      }\n      this.disposes.delete(hash);\n      this.results.set(hash, result);\n      return result;\n    });\n    this.promises.set(hash, promise);\n    return promise;\n  }\n\n  get(input: T) {\n    return this.results.get(this.inputHash(input));\n  }\n\n  cancelLoad(input: T) {\n    const hash = this.inputHash(input);\n    this.promises.delete(hash);\n    const dispose = this.disposes.get(hash);\n    if (dispose) {\n      dispose();\n      this.disposes.delete(hash);\n    }\n  }\n}\n\nexport default WebGLTextureLoaderAsyncHashCache;\n"]},"metadata":{},"sourceType":"script"}