{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * a WebGLTextureLoader handle the loading of WebGLTexture for a given input object.\n */\n\n\nclass WebGLTextureLoader {\n  /**\n   * @property {WebGLRenderingContext} gl - the contextual rendering context\n   */\n\n  /**\n   *\n   */\n  constructor(gl) {\n    _defineProperty(this, \"gl\", void 0);\n\n    this.gl = gl;\n  }\n  /**\n   * Cancel and clear everything\n   */\n\n\n  dispose() {}\n  /**\n   * Check if the loader can handle a given input\n   */\n\n\n  canLoad(input) {\n    return false;\n  }\n  /**\n   * Load the resource by its input. returns a promise of {texture,width,height}.\n   * idempotent: If load() is called twice with the same input, same promise is returned.\n   */\n\n\n  load(input) {\n    return Promise.reject(\"load() is not implemented\");\n  }\n  /**\n   * try to get in sync the texture for a given input. otherwise null/undefined.\n   * If null is returned, load() can be called in order to load the resource that will then be available in a future get() call.\n   */\n\n\n  get(input) {\n    return null;\n  }\n  /**\n   * sync the webgl texture with a loaded input. for instance for <video>/<canvas> elements this needs to be called recurrently (like in a requestAnimationFrame loop) to get the texture updated.\n   * update should only get called IF get(input) was returning a result.\n   */\n\n\n  update(input) {// Default implementation don't do anything which works for all static content like an image\n  }\n\n}\n\nexports.default = WebGLTextureLoader;","map":{"version":3,"sources":["../src/WebGLTextureLoader.js"],"names":["constructor","dispose","canLoad","load","Promise","get","update"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAQA;;;;;AAGe,MAAA,kBAAA,CAA4B;AACzC;;;;AAKA;;;AAGAA,EAAAA,WAAW,CAAA,EAAA,EAA4B;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,IAAA,EAAA,KAAA,CAAA,CAAA;;AACrC,SAAA,EAAA,GAAA,EAAA;AACD;AAED;;;;;AAGAC,EAAAA,OAAO,GAAG,CAAE;AAEZ;;;;;AAGAC,EAAAA,OAAO,CAAA,KAAA,EAAsB;AAC3B,WAAA,KAAA;AACD;AAED;;;;;;AAIAC,EAAAA,IAAI,CAAA,KAAA,EAAoC;AACtC,WAAOC,OAAO,CAAPA,MAAAA,CAAP,2BAAOA,CAAP;AACD;AAED;;;;;;AAIAC,EAAAA,GAAG,CAAA,KAAA,EAA4B;AAC7B,WAAA,IAAA;AACD;AAED;;;;;;AAIAC,EAAAA,MAAM,CAAA,KAAA,EAAiB,CACrB;AACD;;AA/CwC","sourcesContent":["//@flow\n\nexport type TextureAndSize = {\n  texture: WebGLTexture,\n  width: number,\n  height: number\n};\n\n/**\n * a WebGLTextureLoader handle the loading of WebGLTexture for a given input object.\n */\nexport default class WebGLTextureLoader<T> {\n  /**\n   * @property {WebGLRenderingContext} gl - the contextual rendering context\n   */\n  gl: WebGLRenderingContext;\n\n  /**\n   *\n   */\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n  }\n\n  /**\n   * Cancel and clear everything\n   */\n  dispose() {}\n\n  /**\n   * Check if the loader can handle a given input\n   */\n  canLoad(input: any): boolean {\n    return false;\n  }\n\n  /**\n   * Load the resource by its input. returns a promise of {texture,width,height}.\n   * idempotent: If load() is called twice with the same input, same promise is returned.\n   */\n  load(input: T): Promise<TextureAndSize> {\n    return Promise.reject(\"load() is not implemented\");\n  }\n\n  /**\n   * try to get in sync the texture for a given input. otherwise null/undefined.\n   * If null is returned, load() can be called in order to load the resource that will then be available in a future get() call.\n   */\n  get(input: T): ?TextureAndSize {\n    return null;\n  }\n\n  /**\n   * sync the webgl texture with a loaded input. for instance for <video>/<canvas> elements this needs to be called recurrently (like in a requestAnimationFrame loop) to get the texture updated.\n   * update should only get called IF get(input) was returning a result.\n   */\n  update(input: T): void {\n    // Default implementation don't do anything which works for all static content like an image\n  }\n}\n"]},"metadata":{},"sourceType":"script"}