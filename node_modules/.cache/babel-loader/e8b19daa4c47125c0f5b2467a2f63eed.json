{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/serenaantonetti/portfolio-2019/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.list = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _glShader = _interopRequireDefault(require(\"gl-shader\"));\n\nvar _Bus = _interopRequireDefault(require(\"./Bus\"));\n\nvar _Shaders = _interopRequireDefault(require(\"./Shaders\"));\n\nvar _Visitors = _interopRequireDefault(require(\"./Visitors\"));\n\nvar _webgltextureLoader = require(\"webgltexture-loader\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst __DEV__ = process.env.NODE_ENV === \"development\";\n\nconst prependGLSLName = (glsl, name) => !name ? glsl : \"#define SHADER_NAME \" + name + \"\\n\" + glsl;\n\nconst SurfacePropTypes = {\n  children: _propTypes.default.any.isRequired,\n  style: _propTypes.default.any,\n  preload: _propTypes.default.array,\n  onLoad: _propTypes.default.func,\n  onLoadError: _propTypes.default.func,\n  onContextLost: _propTypes.default.func,\n  onContextRestored: _propTypes.default.func,\n  visitor: _propTypes.default.object\n};\nlet surfaceId = 0;\nconst _instances = [];\n\nconst list = () => _instances.slice(0);\n\nexports.list = list;\nconst allSurfaceProps = Object.keys(SurfacePropTypes);\n\nvar _default = ({\n  GLView,\n  RenderLessElement,\n  mapRenderableContent,\n  requestFrame,\n  cancelFrame\n}) => {\n  var _class, _temp;\n  /**\n   * **Renders the final tree of [Node](#node) in a WebGL Canvas / OpenGLView /...**\n   *\n   * `<Surface>` performs the final GL draws for a given implementation.\n   *\n   * `width` and `height` props are required for `gl-react-dom` and `gl-react-headless`, but are not supported for React Native, where the paradigm is to use `style` (and either use flexbox or set a width/height from there).\n   *\n   * > Surface is the only component that isn't \"universal\",\n   * therefore **Surface is exposed by the platform implementation**\n   * (`gl-react-dom` / `gl-react-native` / ...),\n   * unlike the rest of the API exposed through `gl-react`.\n   * Each platform have its own implementation but most props are shared.\n   * If you write a gl-react library, you shouldn't use `<Surface>` but only\n   * let the final user doing it. Therefore your code should remain platform-independant.\n   *\n   * @class Surface\n   * @extends Component\n   * @prop {any} children - a tree of React Element that renders some [Node](#node) and/or [Bus](#bus).\n   * @prop {number} [width] **(only for DOM)** - width of the Surface. multiplied by `pixelRatio` for the actual canvas pixel size.\n   * @prop {number} [height] **(only for DOM)** - height of the Surface. multiplied by `pixelRatio` for the actual canvas pixel size.\n   * @prop {object} [style] - CSS styles that get passed to the underlying `<canvas/>` or `<View/>`\n   * @prop {Array<any>} [preload] - an array of things to preload before the Surface start rendering. Help avoiding blinks and providing required textures to render an initial state.\n   * @prop {function} [onLoad] - a callback called when Surface is ready and just after it rendered.\n   * @prop {function(error:Error):void} [onLoadError] - a callback called when the Surface was not able to load initially.\n   * @prop {function} [onContextLost] - a callback called when the Surface context was lost.\n   * @prop {function} [onContextRestored] - a callback called when the Surface was restored and ready.\n   * @prop {Visitor} [visitor] - an internal visitor used for logs and tests.\n   *\n   * @prop {WebGLContextAttributes} [webglContextAttributes] **(gl-react-dom only)** a optional set of attributes to init WebGL with.\n   * @prop {number} [pixelRatio=window.devicePixelRatio] **(gl-react-dom only)** allows to override the pixelRatio. (default `devicePixelRatio`)\n   *\n   * @example\n   *\n   *  <Surface width={300} height={200}>\n   *    <Node shader={shaders.helloGL} />\n   *  </Surface>\n   *\n   * @example\n   *\n   *  <Surface width={200} height={100}>\n   *    <HelloGL />\n   *  </Surface>\n   *\n   * @example\n   *\n   *  <Surface width={200} height={100}>\n   *    <Blur factor={2}>\n   *      <Negative>\n   *        https://i.imgur.com/wxqlQkh.jpg\n   *      </Negative>\n   *    </Blur>\n   *  </Surface>\n   */\n\n\n  return _temp = _class = class Surface extends _react.Component {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty(this, \"id\", ++surfaceId);\n\n      _defineProperty(this, \"gl\", void 0);\n\n      _defineProperty(this, \"buffer\", void 0);\n\n      _defineProperty(this, \"loaderResolver\", void 0);\n\n      _defineProperty(this, \"glView\", void 0);\n\n      _defineProperty(this, \"root\", void 0);\n\n      _defineProperty(this, \"shaders\", {});\n\n      _defineProperty(this, \"_preparingGL\", []);\n\n      _defineProperty(this, \"_needsRedraw\", false);\n\n      _defineProperty(this, \"state\", {\n        ready: false,\n        rebootId: 0,\n        debug: false\n      });\n\n      _defineProperty(this, \"RenderLessElement\", RenderLessElement);\n\n      _defineProperty(this, \"mapRenderableContent\", mapRenderableContent);\n\n      _defineProperty(this, \"redraw\", () => {\n        this._needsRedraw = true;\n      });\n\n      _defineProperty(this, \"flush\", () => {\n        this._draw();\n      });\n\n      _defineProperty(this, \"_emptyTexture\", void 0);\n\n      _defineProperty(this, \"_onContextCreate\", gl => {\n        const onSuccess = () => {\n          this.setState({\n            ready: true\n          }, () => {\n            try {\n              this._handleLoad();\n            } catch (e) {\n              this._handleError(e);\n            }\n          });\n        };\n\n        this._prepareGL(gl, onSuccess, this._handleError);\n      });\n\n      _defineProperty(this, \"_onContextFailure\", e => {\n        this._handleError(e);\n      });\n\n      _defineProperty(this, \"_onContextLost\", () => {\n        if (this.props.onContextLost) this.props.onContextLost();\n\n        this._stopLoop();\n\n        this._destroyGL();\n\n        if (this.root) this.root._onContextLost();\n      });\n\n      _defineProperty(this, \"_onContextRestored\", gl => {\n        if (this.root) this.root._onContextRestored(gl);\n\n        this._prepareGL(gl, this._handleRestoredSuccess, this._handleRestoredFailure);\n      });\n\n      _defineProperty(this, \"_onRef\", ref => {\n        this.glView = ref;\n      });\n\n      _defineProperty(this, \"_handleError\", e => {\n        const onLoadError = this.props.onLoadError;\n        if (onLoadError) onLoadError(e);else {\n          console.error(e);\n        }\n      });\n\n      _defineProperty(this, \"_handleRestoredFailure\", () => {// there is nothing we can do. it's a dead end.\n      });\n\n      _defineProperty(this, \"_handleRestoredSuccess\", () => {\n        this.redraw();\n        this.flush();\n\n        this._startLoop();\n\n        if (this.props.onContextRestored) this.props.onContextRestored();\n      });\n\n      _defineProperty(this, \"_handleLoad\", () => {\n        if (!this.root) {\n          console.warn(this.getGLName() + \" children does not contain any discoverable Node\");\n        }\n\n        const onLoad = this.props.onLoad;\n        this.redraw();\n        this.flush();\n\n        this._startLoop();\n\n        if (onLoad) onLoad();\n      });\n\n      _defineProperty(this, \"_loopRaf\", void 0);\n    }\n\n    getChildContext() {\n      return {\n        glParent: this,\n        glSurface: this,\n        glSizable: this\n      };\n    }\n\n    componentDidMount() {\n      _instances.push(this);\n\n      this.getVisitors().forEach(v => v.onSurfaceMount(this));\n    }\n\n    componentWillUnmount() {\n      this._stopLoop();\n\n      this._destroyGL();\n\n      const i = _instances.indexOf(this);\n\n      if (i !== -1) _instances.splice(i, 1);\n      this.getVisitors().forEach(v => v.onSurfaceUnmount(this));\n    }\n\n    componentDidUpdate() {\n      this.redraw();\n    }\n\n    render() {\n      const props = this.props,\n            _this$state = this.state,\n            ready = _this$state.ready,\n            rebootId = _this$state.rebootId,\n            debug = _this$state.debug;\n      const children = props.children,\n            style = props.style; // We allow to pass-in all props we don't know so you can hook to DOM events.\n\n      const rest = {};\n      Object.keys(props).forEach(key => {\n        if (allSurfaceProps.indexOf(key) === -1) {\n          rest[key] = props[key];\n        }\n      });\n      return _react.default.createElement(GLView, _extends({\n        key: rebootId,\n        debug: debug,\n        ref: this._onRef,\n        onContextCreate: this._onContextCreate,\n        onContextFailure: this._onContextFailure,\n        onContextLost: this._onContextLost,\n        onContextRestored: this._onContextRestored,\n        style: style\n      }, rest), ready ? children : null);\n    }\n\n    rebootForDebug() {\n      // FIXME: there is a bug somewhere that breaks rendering if this is called at startup time.\n      this._stopLoop();\n\n      this._destroyGL();\n\n      this.setState(({\n        rebootId\n      }) => ({\n        rebootId: rebootId + 1,\n        ready: false,\n        debug: true\n      }));\n    }\n\n    getVisitors() {\n      return _Visitors.default.get().concat(this.props.visitor || []);\n    }\n\n    getGLSize() {\n      const gl = this.gl;\n      return [gl ? gl.drawingBufferWidth : 0, gl ? gl.drawingBufferHeight : 0];\n    }\n\n    getGLName() {\n      return `Surface#${this.id}`;\n    }\n\n    getGLShortName() {\n      return \"Surface\";\n    }\n    /**\n     * see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL\n     * @param {string} mimeType (optional) the image MimeType\n     * @param {number} quality (optional) the image quality\n     * @memberof Surface\n     * @instance\n     */\n\n\n    captureAsDataURL(...args) {\n      const glView = this.glView;\n      (0, _invariant.default)(glView, \"GLView is mounted\");\n      (0, _invariant.default)(glView.captureAsDataURL, \"captureAsDataURL is not defined in %s\", GLView.displayName || GLView.name);\n      return glView.captureAsDataURL(...args);\n    }\n    /**\n     * see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n     * @param {string} mimeType (optional) the image MimeType\n     * @param {number} quality (optional) the image quality\n     * @memberof Surface\n     * @instance\n     */\n\n\n    captureAsBlob(...args) {\n      const glView = this.glView;\n      (0, _invariant.default)(glView, \"GLView is mounted\");\n      (0, _invariant.default)(glView.captureAsBlob, \"captureAsBlob is not defined in %s\", GLView.displayName || GLView.name);\n      return glView.captureAsBlob(...args);\n    }\n    /**\n     * capture the root Node pixels. Make sure you have set `preserveDrawingBuffer: true` in `webglContextAttributes` prop.\n     * @memberof Surface\n     * @instance\n     */\n\n\n    capture(x, y, w, h) {\n      (0, _invariant.default)(this.root, \"Surface#capture: surface is not yet ready or don't have any root Node\");\n      return this.root.capture(x, y, w, h);\n    }\n    /**\n     * Schedule a redraw of the Surface.\n     * @memberof Surface\n     * @instance\n     * @function\n     */\n\n\n    glIsAvailable() {\n      return !!this.gl;\n    }\n\n    getEmptyTexture() {\n      let gl = this.gl,\n          _emptyTexture = this._emptyTexture;\n      (0, _invariant.default)(gl, \"getEmptyTexture called while gl was not defined\");\n\n      if (!_emptyTexture) {\n        this._emptyTexture = _emptyTexture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, _emptyTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\n      }\n\n      return _emptyTexture;\n    }\n\n    _destroyGL() {\n      const gl = this.gl;\n\n      if (gl) {\n        this.gl = null;\n\n        if (this._emptyTexture) {\n          gl.deleteTexture(this._emptyTexture);\n          this._emptyTexture = null;\n        }\n\n        if (this.loaderResolver) {\n          this.loaderResolver.dispose();\n        }\n\n        for (let k in this.shaders) {\n          this.shaders[k].dispose();\n        }\n\n        this.shaders = {};\n        gl.deleteBuffer(this.buffer);\n        this.getVisitors().map(v => v.onSurfaceGLContextChange(this, null));\n      }\n    }\n\n    _prepareGL(gl, onSuccess, onError) {\n      this.gl = gl;\n      this.getVisitors().map(v => v.onSurfaceGLContextChange(this, gl));\n      this.loaderResolver = new _webgltextureLoader.LoaderResolver(gl);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 4, 4, -1]), // see a-big-triangle\n      gl.STATIC_DRAW);\n      this.buffer = buffer;\n      const preload = this.props.preload;\n      const all = [];\n      (preload || []).forEach(raw => {\n        if (!raw) {\n          console.warn(\"Can't preload value\", raw);\n          return;\n        }\n\n        const _this$_resolveTexture = this._resolveTextureLoader(raw),\n              loader = _this$_resolveTexture.loader,\n              input = _this$_resolveTexture.input;\n\n        if (!loader) {\n          console.warn(\"Can't preload input\", raw, input);\n          return;\n        }\n\n        const loadedAlready = loader.get(input);\n        if (loadedAlready) return;\n        all.push(loader.load(input));\n      });\n      this._preparingGL = all;\n\n      if (all.length > 0) {\n        Promise.all(all).then(onSuccess, onError); // FIXME make sure this never finish if _prepareGL is called again.\n      } else {\n        onSuccess();\n      }\n    }\n\n    _addGLNodeChild(node) {\n      (0, _invariant.default)(!this.root, \"Surface can only contains a single root. Got: %s\", this.root && this.root.getGLName());\n      this.root = node;\n\n      node._addDependent(this);\n\n      this.redraw();\n    }\n\n    _removeGLNodeChild(node) {\n      this.root = null;\n      this.redraw();\n    }\n\n    _resolveTextureLoader(raw) {\n      let input = raw;\n      let loader = this.loaderResolver && this.loaderResolver.resolve(input);\n      return {\n        loader,\n        input\n      };\n    }\n\n    _makeShader({\n      frag,\n      vert\n    }, name) {\n      const gl = this.gl;\n      (0, _invariant.default)(gl, \"gl is not available\");\n      const shader = (0, _glShader.default)(gl, prependGLSLName(vert, name), prependGLSLName(frag, name));\n\n      shader.attributes._p.pointer();\n\n      return shader;\n    }\n\n    _getShader(shaderId) {\n      const shaders = this.shaders;\n      return shaders[shaderId.id] || (shaders[shaderId.id] = this._makeShader(_Shaders.default.get(shaderId), _Shaders.default.getName(shaderId)));\n    }\n\n    _bindRootNode() {\n      const gl = this.gl;\n      (0, _invariant.default)(gl, \"gl context not available\");\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n      const _this$getGLSize = this.getGLSize(),\n            _this$getGLSize2 = _slicedToArray(_this$getGLSize, 2),\n            width = _this$getGLSize2[0],\n            height = _this$getGLSize2[1];\n\n      gl.viewport(0, 0, width, height);\n    }\n\n    _startLoop() {\n      cancelFrame(this._loopRaf);\n\n      const loop = () => {\n        this._loopRaf = requestFrame(loop);\n        if (this._needsRedraw) this._draw();\n      };\n\n      this._loopRaf = requestFrame(loop);\n    }\n\n    _stopLoop() {\n      cancelFrame(this._loopRaf);\n    }\n\n    _draw() {\n      const gl = this.gl,\n            root = this.root,\n            glView = this.glView;\n      (0, _invariant.default)(glView, \"GLView is mounted\");\n      const visitors = this.getVisitors();\n\n      if (!gl || !root || !this._needsRedraw) {\n        visitors.forEach(v => v.onSurfaceDrawSkipped(this));\n        return;\n      }\n\n      this._needsRedraw = false;\n      visitors.forEach(v => v.onSurfaceDrawStart(this));\n      if (glView.beforeDraw) glView.beforeDraw(gl);\n\n      try {\n        root._draw();\n      } catch (e) {\n        let silent = false;\n        visitors.forEach(v => {\n          silent = v.onSurfaceDrawError(e) || silent;\n        });\n\n        if (!silent) {\n          if (__DEV__ && glView.debugError && e.longMessage\n          /* duck typing an \"interesting\" GLError (from lib gl-shader) */\n          ) {\n              glView.debugError(e);\n            } else {\n            console.warn(e);\n            throw e;\n          }\n        }\n\n        return;\n      }\n\n      if (glView.afterDraw) glView.afterDraw(gl);\n      visitors.forEach(v => v.onSurfaceDrawEnd(this));\n    }\n\n  }, _defineProperty(_class, \"propTypes\", SurfacePropTypes), _defineProperty(_class, \"childContextTypes\", {\n    glSurface: _propTypes.default.object.isRequired,\n    glParent: _propTypes.default.object.isRequired,\n    glSizable: _propTypes.default.object.isRequired\n  }), _temp;\n};\n\nexports.default = _default;","map":{"version":3,"sources":["../src/createSurface.js"],"names":["__DEV__","process","prependGLSLName","SurfacePropTypes","children","PropTypes","style","preload","onLoad","onLoadError","onContextLost","onContextRestored","visitor","object","surfaceId","_instances","list","allSurfaceProps","Object","cancelFrame","Component","ready","rebootId","debug","glSurface","glParent","glSizable","isRequired","getChildContext","componentDidMount","v","componentWillUnmount","i","componentDidUpdate","render","state","rest","key","props","rebootForDebug","getVisitors","Visitors","getGLSize","gl","getGLName","id","getGLShortName","captureAsDataURL","glView","GLView","captureAsBlob","capture","glIsAvailable","getEmptyTexture","_emptyTexture","onSuccess","e","_destroyGL","_prepareGL","LoaderResolver","buffer","all","raw","console","input","loadedAlready","loader","Promise","ref","_addGLNodeChild","node","_removeGLNodeChild","_resolveTextureLoader","_makeShader","vert","shader","_getShader","shaders","shaderId","Shaders","_bindRootNode","_startLoop","loop","requestFrame","_stopLoop","_draw","visitors","root","silent","longMessage"],"mappings":"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","sourcesContent":["//@flow\nimport invariant from \"invariant\";\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport createShader from \"gl-shader\";\nimport Bus from \"./Bus\";\nimport Shaders from \"./Shaders\";\nimport Visitors from \"./Visitors\";\nimport { LoaderResolver } from \"webgltexture-loader\";\nimport type { NDArray } from \"ndarray\";\nimport type { ShaderIdentifier, ShaderInfo } from \"./Shaders\";\nimport type { Shader } from \"gl-shader\";\nimport type { VisitorLike } from \"./Visitor\";\nimport type { WebGLTextureLoader } from \"webgltexture-loader\";\nimport type Node from \"./Node\";\n\nconst __DEV__ = process.env.NODE_ENV === \"development\";\n\nconst prependGLSLName = (glsl: string, name: ?string) =>\n  !name ? glsl : \"#define SHADER_NAME \" + name + \"\\n\" + glsl;\n\ntype SurfaceProps = {\n  children?: any,\n  style?: Object,\n  preload?: Array<mixed>,\n  onLoad?: () => void,\n  onLoadError?: (e: Error) => void,\n  onContextLost?: () => void,\n  onContextRestored?: () => void,\n  visitor?: VisitorLike\n};\n\ninterface ISurface extends Component<SurfaceProps, *> {\n  props: SurfaceProps;\n  gl: ?WebGLRenderingContext;\n  RenderLessElement: React$ComponentType<*>;\n  root: ?Node;\n  id: number;\n\n  +mapRenderableContent: ?(inst: mixed) => mixed;\n  +getVisitors: () => Array<VisitorLike>;\n  +getGLSize: () => [number, number];\n  +getGLName: () => string;\n  +getGLShortName: () => string;\n  +captureAsDataURL: (...args: any) => string;\n  +captureAsBlob: (...args: any) => Promise<Blob>;\n  +capture: (x?: number, y?: number, w?: number, h?: number) => NDArray;\n  +redraw: () => void;\n  +flush: () => void;\n  +getEmptyTexture: () => WebGLTexture;\n  +glIsAvailable: () => boolean;\n\n  +rebootForDebug: () => void;\n  +_addGLNodeChild: (node: Node) => void;\n  +_removeGLNodeChild: (node: Node) => void;\n  +_resolveTextureLoader: (\n    raw: any\n  ) => { loader: ?WebGLTextureLoader<*>, input: mixed };\n  +_getShader: (shaderId: ShaderIdentifier) => Shader;\n  +_makeShader: (shaderInfo: ShaderInfo) => Shader;\n  +_draw: () => void;\n  +_bindRootNode: () => void;\n}\n\nexport type Surface = ISurface;\n\nexport type SurfaceContext = {\n  glParent: Node | Surface | Bus,\n  glSurface: Surface,\n  glSizable: { +getGLSize: () => [number, number] }\n};\n\nconst SurfacePropTypes = {\n  children: PropTypes.any.isRequired,\n  style: PropTypes.any,\n  preload: PropTypes.array,\n  onLoad: PropTypes.func,\n  onLoadError: PropTypes.func,\n  onContextLost: PropTypes.func,\n  onContextRestored: PropTypes.func,\n  visitor: PropTypes.object\n};\n\nlet surfaceId = 0;\nconst _instances: Array<ISurface> = [];\nexport const list = (): Array<ISurface> => _instances.slice(0);\n\nconst allSurfaceProps = Object.keys(SurfacePropTypes);\n\ntype SurfaceOpts = {\n  GLView: *,\n  RenderLessElement: React$ComponentType<*>,\n  mapRenderableContent?: (instance: mixed) => mixed,\n  requestFrame: (f: Function) => number,\n  cancelFrame: (id: number) => void\n};\n\nexport default ({\n  GLView,\n  RenderLessElement,\n  mapRenderableContent,\n  requestFrame,\n  cancelFrame\n}: SurfaceOpts): Class<ISurface> => {\n  /**\n   * **Renders the final tree of [Node](#node) in a WebGL Canvas / OpenGLView /...**\n   *\n   * `<Surface>` performs the final GL draws for a given implementation.\n   *\n   * `width` and `height` props are required for `gl-react-dom` and `gl-react-headless`, but are not supported for React Native, where the paradigm is to use `style` (and either use flexbox or set a width/height from there).\n   *\n   * > Surface is the only component that isn't \"universal\",\n   * therefore **Surface is exposed by the platform implementation**\n   * (`gl-react-dom` / `gl-react-native` / ...),\n   * unlike the rest of the API exposed through `gl-react`.\n   * Each platform have its own implementation but most props are shared.\n   * If you write a gl-react library, you shouldn't use `<Surface>` but only\n   * let the final user doing it. Therefore your code should remain platform-independant.\n   *\n   * @class Surface\n   * @extends Component\n   * @prop {any} children - a tree of React Element that renders some [Node](#node) and/or [Bus](#bus).\n   * @prop {number} [width] **(only for DOM)** - width of the Surface. multiplied by `pixelRatio` for the actual canvas pixel size.\n   * @prop {number} [height] **(only for DOM)** - height of the Surface. multiplied by `pixelRatio` for the actual canvas pixel size.\n   * @prop {object} [style] - CSS styles that get passed to the underlying `<canvas/>` or `<View/>`\n   * @prop {Array<any>} [preload] - an array of things to preload before the Surface start rendering. Help avoiding blinks and providing required textures to render an initial state.\n   * @prop {function} [onLoad] - a callback called when Surface is ready and just after it rendered.\n   * @prop {function(error:Error):void} [onLoadError] - a callback called when the Surface was not able to load initially.\n   * @prop {function} [onContextLost] - a callback called when the Surface context was lost.\n   * @prop {function} [onContextRestored] - a callback called when the Surface was restored and ready.\n   * @prop {Visitor} [visitor] - an internal visitor used for logs and tests.\n   *\n   * @prop {WebGLContextAttributes} [webglContextAttributes] **(gl-react-dom only)** a optional set of attributes to init WebGL with.\n   * @prop {number} [pixelRatio=window.devicePixelRatio] **(gl-react-dom only)** allows to override the pixelRatio. (default `devicePixelRatio`)\n   *\n   * @example\n   *\n   *  <Surface width={300} height={200}>\n   *    <Node shader={shaders.helloGL} />\n   *  </Surface>\n   *\n   * @example\n   *\n   *  <Surface width={200} height={100}>\n   *    <HelloGL />\n   *  </Surface>\n   *\n   * @example\n   *\n   *  <Surface width={200} height={100}>\n   *    <Blur factor={2}>\n   *      <Negative>\n   *        https://i.imgur.com/wxqlQkh.jpg\n   *      </Negative>\n   *    </Blur>\n   *  </Surface>\n   */\n  return class Surface extends Component<\n    SurfaceProps,\n    {\n      ready: boolean,\n      rebootId: number,\n      debug: boolean\n    }\n  > {\n    id: number = ++surfaceId;\n    gl: ?WebGLRenderingContext;\n    buffer: WebGLBuffer;\n    loaderResolver: ?LoaderResolver;\n    glView: *;\n    root: ?Node;\n    shaders: { [key: string]: Shader } = {};\n    _preparingGL: Array<*> = [];\n    _needsRedraw: boolean = false;\n    state = {\n      ready: false,\n      rebootId: 0,\n      debug: false\n    };\n\n    RenderLessElement = RenderLessElement;\n    mapRenderableContent = mapRenderableContent;\n\n    static propTypes = SurfacePropTypes;\n    static childContextTypes: { [_: $Keys<SurfaceContext>]: any } = {\n      glSurface: PropTypes.object.isRequired,\n      glParent: PropTypes.object.isRequired,\n      glSizable: PropTypes.object.isRequired\n    };\n\n    getChildContext(): SurfaceContext {\n      return {\n        glParent: this,\n        glSurface: this,\n        glSizable: this\n      };\n    }\n\n    componentDidMount() {\n      _instances.push(this);\n      this.getVisitors().forEach(v => v.onSurfaceMount(this));\n    }\n\n    componentWillUnmount() {\n      this._stopLoop();\n      this._destroyGL();\n      const i = _instances.indexOf(this);\n      if (i !== -1) _instances.splice(i, 1);\n      this.getVisitors().forEach(v => v.onSurfaceUnmount(this));\n    }\n\n    componentDidUpdate() {\n      this.redraw();\n    }\n\n    render() {\n      const {\n        props,\n        state: { ready, rebootId, debug }\n      } = this;\n      const { children, style } = props;\n\n      // We allow to pass-in all props we don't know so you can hook to DOM events.\n      const rest = {};\n      Object.keys(props).forEach(key => {\n        if (allSurfaceProps.indexOf(key) === -1) {\n          rest[key] = props[key];\n        }\n      });\n\n      return (\n        <GLView\n          key={rebootId}\n          debug={debug}\n          ref={this._onRef}\n          onContextCreate={this._onContextCreate}\n          onContextFailure={this._onContextFailure}\n          onContextLost={this._onContextLost}\n          onContextRestored={this._onContextRestored}\n          style={style}\n          {...rest}\n        >\n          {ready ? children : null}\n        </GLView>\n      );\n    }\n\n    rebootForDebug() {\n      // FIXME: there is a bug somewhere that breaks rendering if this is called at startup time.\n      this._stopLoop();\n      this._destroyGL();\n      this.setState(({ rebootId }) => ({\n        rebootId: rebootId + 1,\n        ready: false,\n        debug: true\n      }));\n    }\n\n    getVisitors(): Array<VisitorLike> {\n      return Visitors.get().concat(this.props.visitor || []);\n    }\n\n    getGLSize(): [number, number] {\n      const { gl } = this;\n      return [gl ? gl.drawingBufferWidth : 0, gl ? gl.drawingBufferHeight : 0];\n    }\n\n    getGLName(): string {\n      return `Surface#${this.id}`;\n    }\n\n    getGLShortName(): string {\n      return \"Surface\";\n    }\n\n    /**\n     * see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL\n     * @param {string} mimeType (optional) the image MimeType\n     * @param {number} quality (optional) the image quality\n     * @memberof Surface\n     * @instance\n     */\n    captureAsDataURL(...args: any): string {\n      const { glView } = this;\n      invariant(glView, \"GLView is mounted\");\n      invariant(\n        glView.captureAsDataURL,\n        \"captureAsDataURL is not defined in %s\",\n        GLView.displayName || GLView.name\n      );\n      return glView.captureAsDataURL(...args);\n    }\n\n    /**\n     * see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n     * @param {string} mimeType (optional) the image MimeType\n     * @param {number} quality (optional) the image quality\n     * @memberof Surface\n     * @instance\n     */\n    captureAsBlob(...args: any): Promise<Blob> {\n      const { glView } = this;\n      invariant(glView, \"GLView is mounted\");\n      invariant(\n        glView.captureAsBlob,\n        \"captureAsBlob is not defined in %s\",\n        GLView.displayName || GLView.name\n      );\n      return glView.captureAsBlob(...args);\n    }\n\n    /**\n     * capture the root Node pixels. Make sure you have set `preserveDrawingBuffer: true` in `webglContextAttributes` prop.\n     * @memberof Surface\n     * @instance\n     */\n    capture(x?: number, y?: number, w?: number, h?: number): NDArray {\n      invariant(\n        this.root,\n        \"Surface#capture: surface is not yet ready or don't have any root Node\"\n      );\n      return this.root.capture(x, y, w, h);\n    }\n\n    /**\n     * Schedule a redraw of the Surface.\n     * @memberof Surface\n     * @instance\n     * @function\n     */\n    redraw = (): void => {\n      this._needsRedraw = true;\n    };\n\n    /**\n     * Force the redraw (if any) to happen now, synchronously.\n     * @memberof Surface\n     * @instance\n     * @function\n     */\n    flush = (): void => {\n      this._draw();\n    };\n\n    glIsAvailable(): boolean {\n      return !!this.gl;\n    }\n\n    _emptyTexture: ?WebGLTexture;\n    getEmptyTexture(): WebGLTexture {\n      let { gl, _emptyTexture } = this;\n      invariant(gl, \"getEmptyTexture called while gl was not defined\");\n      if (!_emptyTexture) {\n        this._emptyTexture = _emptyTexture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, _emptyTexture);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          gl.RGBA,\n          2,\n          2,\n          0,\n          gl.RGBA,\n          gl.UNSIGNED_BYTE,\n          new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n        );\n      }\n      return _emptyTexture;\n    }\n\n    _onContextCreate = (gl: WebGLRenderingContext): void => {\n      const onSuccess = () => {\n        this.setState(\n          {\n            ready: true\n          },\n          () => {\n            try {\n              this._handleLoad();\n            } catch (e) {\n              this._handleError(e);\n            }\n          }\n        );\n      };\n      this._prepareGL(gl, onSuccess, this._handleError);\n    };\n\n    _onContextFailure = (e: Error): void => {\n      this._handleError(e);\n    };\n\n    _onContextLost = (): void => {\n      if (this.props.onContextLost) this.props.onContextLost();\n      this._stopLoop();\n      this._destroyGL();\n      if (this.root) this.root._onContextLost();\n    };\n\n    _onContextRestored = (gl: WebGLRenderingContext) => {\n      if (this.root) this.root._onContextRestored(gl);\n      this._prepareGL(\n        gl,\n        this._handleRestoredSuccess,\n        this._handleRestoredFailure\n      );\n    };\n\n    _destroyGL() {\n      const { gl } = this;\n      if (gl) {\n        this.gl = null;\n        if (this._emptyTexture) {\n          gl.deleteTexture(this._emptyTexture);\n          this._emptyTexture = null;\n        }\n        if (this.loaderResolver) {\n          this.loaderResolver.dispose();\n        }\n        for (let k in this.shaders) {\n          this.shaders[k].dispose();\n        }\n        this.shaders = {};\n        gl.deleteBuffer(this.buffer);\n        this.getVisitors().map(v => v.onSurfaceGLContextChange(this, null));\n      }\n    }\n\n    _prepareGL(\n      gl: WebGLRenderingContext,\n      onSuccess: () => void,\n      onError: (e: Error) => void\n    ) {\n      this.gl = gl;\n      this.getVisitors().map(v => v.onSurfaceGLContextChange(this, gl));\n\n      this.loaderResolver = new LoaderResolver(gl);\n\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(\n        gl.ARRAY_BUFFER,\n        new Float32Array([-1, -1, -1, 4, 4, -1]), // see a-big-triangle\n        gl.STATIC_DRAW\n      );\n      this.buffer = buffer;\n\n      const { preload } = this.props;\n\n      const all: Array<Promise<*>> = [];\n\n      (preload || []).forEach(raw => {\n        if (!raw) {\n          console.warn(\"Can't preload value\", raw);\n          return;\n        }\n        const { loader, input } = this._resolveTextureLoader(raw);\n        if (!loader) {\n          console.warn(\"Can't preload input\", raw, input);\n          return;\n        }\n        const loadedAlready = loader.get(input);\n        if (loadedAlready) return;\n        all.push(loader.load(input));\n      });\n\n      this._preparingGL = all;\n\n      if (all.length > 0) {\n        Promise.all(all).then(onSuccess, onError); // FIXME make sure this never finish if _prepareGL is called again.\n      } else {\n        onSuccess();\n      }\n    }\n\n    _onRef = (ref: ?GLView): void => {\n      this.glView = ref;\n    };\n\n    _addGLNodeChild(node: Node): void {\n      invariant(\n        !this.root,\n        \"Surface can only contains a single root. Got: %s\",\n        this.root && this.root.getGLName()\n      );\n      this.root = node;\n      node._addDependent(this);\n      this.redraw();\n    }\n    _removeGLNodeChild(node: Node): void {\n      this.root = null;\n      this.redraw();\n    }\n\n    _handleError = (e: Error): void => {\n      const { onLoadError } = this.props;\n      if (onLoadError) onLoadError(e);\n      else {\n        console.error(e);\n      }\n    };\n\n    _handleRestoredFailure = (): void => {\n      // there is nothing we can do. it's a dead end.\n    };\n\n    _handleRestoredSuccess = (): void => {\n      this.redraw();\n      this.flush();\n      this._startLoop();\n      if (this.props.onContextRestored) this.props.onContextRestored();\n    };\n\n    _handleLoad = (): void => {\n      if (!this.root) {\n        console.warn(\n          this.getGLName() + \" children does not contain any discoverable Node\"\n        );\n      }\n      const { onLoad } = this.props;\n      this.redraw();\n      this.flush();\n      this._startLoop();\n      if (onLoad) onLoad();\n    };\n\n    _resolveTextureLoader(\n      raw: mixed\n    ): { loader: ?WebGLTextureLoader<*>, input: any } {\n      let input = raw;\n      let loader: ?WebGLTextureLoader<*> =\n        this.loaderResolver && this.loaderResolver.resolve(input);\n      return { loader, input };\n    }\n\n    _makeShader({ frag, vert }: ShaderInfo, name?: string): Shader {\n      const { gl } = this;\n      invariant(gl, \"gl is not available\");\n      const shader = createShader(\n        gl,\n        prependGLSLName(vert, name),\n        prependGLSLName(frag, name)\n      );\n      shader.attributes._p.pointer();\n      return shader;\n    }\n\n    _getShader(shaderId: ShaderIdentifier): Shader {\n      const { shaders } = this;\n      return (\n        shaders[shaderId.id] ||\n        (shaders[shaderId.id] = this._makeShader(\n          Shaders.get(shaderId),\n          Shaders.getName(shaderId)\n        ))\n      );\n    }\n\n    _bindRootNode(): void {\n      const { gl } = this;\n      invariant(gl, \"gl context not available\");\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      const [width, height] = this.getGLSize();\n      gl.viewport(0, 0, width, height);\n    }\n\n    _loopRaf: any;\n    _startLoop(): void {\n      cancelFrame(this._loopRaf);\n      const loop = () => {\n        this._loopRaf = requestFrame(loop);\n        if (this._needsRedraw) this._draw();\n      };\n      this._loopRaf = requestFrame(loop);\n    }\n\n    _stopLoop(): void {\n      cancelFrame(this._loopRaf);\n    }\n\n    _draw(): void {\n      const { gl, root, glView } = this;\n      invariant(glView, \"GLView is mounted\");\n      const visitors = this.getVisitors();\n      if (!gl || !root || !this._needsRedraw) {\n        visitors.forEach(v => v.onSurfaceDrawSkipped(this));\n        return;\n      }\n      this._needsRedraw = false;\n      visitors.forEach(v => v.onSurfaceDrawStart(this));\n      if (glView.beforeDraw) glView.beforeDraw(gl);\n      try {\n        root._draw();\n      } catch (e) {\n        let silent = false;\n        visitors.forEach(v => {\n          silent = v.onSurfaceDrawError(e) || silent;\n        });\n        if (!silent) {\n          if (\n            __DEV__ &&\n            glView.debugError &&\n            e.longMessage /* duck typing an \"interesting\" GLError (from lib gl-shader) */\n          ) {\n            glView.debugError(e);\n          } else {\n            console.warn(e);\n            throw e;\n          }\n        }\n        return;\n      }\n      if (glView.afterDraw) glView.afterDraw(gl);\n      visitors.forEach(v => v.onSurfaceDrawEnd(this));\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}