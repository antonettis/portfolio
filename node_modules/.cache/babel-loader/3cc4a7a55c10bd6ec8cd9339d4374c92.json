{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _Node = _interopRequireDefault(require(\"./Node\"));\n\nvar _invariantNoDependentsLoop = _interopRequireDefault(require(\"./helpers/invariantNoDependentsLoop\"));\n\nvar _genId = _interopRequireDefault(require(\"./genId\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * a **Bus is a container to \"cache\" and re-use content** (tree of Node, canvas, video,...) somewhere else in your GL graph.\n * To use it, use the Bus `ref`:\n * - provide it in another Node texture uniform so you can share computation (send a Node texture to multiple Nodes dependent) (more exactly, a working pattern is to give a `()=>ref` function that will be resolved in `DidUpdate` lifecycle)\n * - You have a `capture()` method to snapshot the underlying Node (because Node can be hidden being nested React components).\n *\n *\n * @prop {any} children the content to render. It can also be a function that takes a redraw function and render an element.\n * @prop {string} [uniform] In case you want to explicitely draw Bus directly into a uniform, you can give the uniform name of the parent node.\n * If this prop is not used, the Bus does not directly belong to a Node and a ref can be used to indirectly give a texture to a node.\n * `uniform` is equivalent to directly pass your VDOM inside the Node uniforms prop.\n *\n * **Usage Example**\n *\n * [![](https://github.com/ProjectSeptemberInc/gl-react/raw/master/docs/examples/blur.gif)](/blurmapmouse)\n *\n * @example\n *\n * <Surface ...>\n *   <Bus ref=\"myBus\">\n *     //here, glEffects or content like a canvas/video...\n *   </Bus>\n *   <Node uniforms={{\n *     texture: () => this.refs.myBus\n *   }} ... />\n * </Surface>\n *\n */\n\n\nclass Bus extends _react.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"id\", (0, _genId.default)());\n\n    _defineProperty(this, \"context\", void 0);\n\n    _defineProperty(this, \"dependents\", []);\n\n    _defineProperty(this, \"glNode\", null);\n\n    _defineProperty(this, \"glBusRootNode\", void 0);\n\n    _defineProperty(this, \"onRef\", ref => {\n      this.glBusRootNode = ref;\n    });\n\n    _defineProperty(this, \"redraw\", () => {\n      this.dependents.forEach(d => d.redraw());\n    });\n\n    _defineProperty(this, \"_draw\", () => {// FIXME: _draw() on a Bus? (would a third party need this?)\n    });\n  }\n\n  componentDidMount() {\n    const _this$props = this.props,\n          uniform = _this$props.uniform,\n          index = _this$props.index;\n\n    if (uniform) {\n      const glParent = this.context.glParent;\n      (0, _invariant.default)(glParent instanceof _Node.default, 'a <Bus uniform=\"..\" /> needs to be inside a Node');\n\n      glParent._addUniformBus(this, uniform, index);\n    }\n\n    this.redraw();\n  }\n\n  componentWillUnmount() {\n    const _this$props2 = this.props,\n          uniform = _this$props2.uniform,\n          index = _this$props2.index;\n\n    if (uniform) {\n      const glParent = this.context.glParent;\n      (0, _invariant.default)(glParent instanceof _Node.default, 'a <Bus uniform=\"..\" /> needs to be inside a Node');\n\n      glParent._removeUniformBus(this, uniform, index);\n    }\n  }\n\n  componentDidUpdate({\n    uniform: oldUniform,\n    index: oldIndex\n  }) {\n    const _this$props3 = this.props,\n          uniform = _this$props3.uniform,\n          index = _this$props3.index;\n\n    if (uniform && (uniform !== oldUniform || index !== oldIndex)) {\n      const glParent = this.context.glParent;\n      (0, _invariant.default)(glParent instanceof _Node.default, 'a <Bus uniform=\"..\" /> needs to be inside a Node');\n      if (oldUniform) glParent._removeUniformBus(this, oldUniform, oldIndex);\n\n      glParent._addUniformBus(this, uniform, index);\n    }\n\n    this.redraw();\n  }\n\n  getChildContext() {\n    return {\n      glParent: this\n    };\n  }\n\n  _addGLNodeChild(node) {\n    this.glNode = node;\n    this.context.glParent.redraw();\n  }\n\n  _removeGLNodeChild(node) {\n    this.glNode = null;\n  }\n\n  _addDependent(node) {\n    const i = this.dependents.indexOf(node);\n\n    if (i === -1) {\n      (0, _invariantNoDependentsLoop.default)(this, node);\n      this.dependents.push(node);\n    }\n  }\n\n  _removeDependent(node) {\n    const i = this.dependents.indexOf(node);\n    if (i !== -1) this.dependents.splice(i, 1);\n  }\n\n  getGLRenderableNode() {\n    return this.glNode;\n  }\n\n  getGLRenderableContent() {\n    const mapRenderableContent = this.context.glSurface.mapRenderableContent;\n    const glBusRootNode = this.glBusRootNode;\n    return glBusRootNode && mapRenderableContent ? mapRenderableContent(glBusRootNode) : null;\n  }\n\n  getGLName() {\n    return `Bus(${this.glNode ? this.glNode.getGLName() : String(this.getGLRenderableContent())})`;\n  }\n\n  getGLShortName() {\n    const content = this.getGLRenderableContent();\n    const shortContentName = String(content && content.constructor && content.constructor.name || content);\n    return `Bus(${this.glNode ? this.glNode.getGLShortName() : shortContentName})`;\n  }\n  /**\n   * Capture the underlying Node pixels.\n   * NB it only works for nodes, not for content like video/canvas.\n   */\n\n\n  capture(x, y, w, h) {\n    (0, _invariant.default)(this.glNode, \"Bus does not contain any Node\");\n    return this.glNode.capture(x, y, w, h);\n  }\n\n  _onContextLost() {\n    const glNode = this.glNode;\n    if (glNode) glNode._onContextLost();\n  }\n\n  _onContextRestored(gl) {\n    const glNode = this.glNode;\n    if (glNode) glNode._onContextRestored(gl);\n  }\n\n  render() {\n    const children = this.props.children;\n    const _this$context$glSurfa = this.context.glSurface,\n          RenderLessElement = _this$context$glSurfa.RenderLessElement,\n          mapRenderableContent = _this$context$glSurfa.mapRenderableContent;\n    return _react.default.createElement(RenderLessElement, {\n      ref: mapRenderableContent ? this.onRef : undefined\n    }, typeof children === \"function\" ? children(this.redraw) : children);\n  }\n\n}\n\nexports.default = Bus;\n\n_defineProperty(Bus, \"defaultProps\", {\n  index: 0\n});\n\n_defineProperty(Bus, \"contextTypes\", {\n  glParent: _propTypes.default.object.isRequired,\n  glSurface: _propTypes.default.object.isRequired\n});\n\n_defineProperty(Bus, \"childContextTypes\", {\n  glParent: _propTypes.default.object.isRequired\n});","map":{"version":3,"sources":["../src/Bus.js"],"names":["Bus","Component","index","glParent","PropTypes","glSurface","isRequired","componentDidMount","Node","componentWillUnmount","componentDidUpdate","uniform","oldIndex","getChildContext","_addGLNodeChild","_removeGLNodeChild","_addDependent","i","_removeDependent","getGLRenderableNode","getGLRenderableContent","mapRenderableContent","glBusRootNode","getGLName","String","getGLShortName","content","shortContentName","capture","ref","d","_onContextLost","glNode","_onContextRestored","render","children","undefined"],"mappings":"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","sourcesContent":["//@flow\nimport invariant from \"invariant\";\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Node from \"./Node\";\nimport invariantNoDependentsLoop from \"./helpers/invariantNoDependentsLoop\";\nimport genId from \"./genId\";\n\nimport type { Surface } from \"./createSurface\";\nimport type { NDArray } from \"ndarray\";\n\ntype Props = {|\n  children?: React$Element<*> | ((redraw?: () => void) => React$Element<*>),\n  uniform?: string,\n  index: number\n|};\n\n/**\n * a **Bus is a container to \"cache\" and re-use content** (tree of Node, canvas, video,...) somewhere else in your GL graph.\n * To use it, use the Bus `ref`:\n * - provide it in another Node texture uniform so you can share computation (send a Node texture to multiple Nodes dependent) (more exactly, a working pattern is to give a `()=>ref` function that will be resolved in `DidUpdate` lifecycle)\n * - You have a `capture()` method to snapshot the underlying Node (because Node can be hidden being nested React components).\n *\n *\n * @prop {any} children the content to render. It can also be a function that takes a redraw function and render an element.\n * @prop {string} [uniform] In case you want to explicitely draw Bus directly into a uniform, you can give the uniform name of the parent node.\n * If this prop is not used, the Bus does not directly belong to a Node and a ref can be used to indirectly give a texture to a node.\n * `uniform` is equivalent to directly pass your VDOM inside the Node uniforms prop.\n *\n * **Usage Example**\n *\n * [![](https://github.com/ProjectSeptemberInc/gl-react/raw/master/docs/examples/blur.gif)](/blurmapmouse)\n *\n * @example\n *\n * <Surface ...>\n *   <Bus ref=\"myBus\">\n *     //here, glEffects or content like a canvas/video...\n *   </Bus>\n *   <Node uniforms={{\n *     texture: () => this.refs.myBus\n *   }} ... />\n * </Surface>\n *\n */\nexport default class Bus extends Component<Props, *> {\n  id: number = genId();\n  context: {\n    glParent: Surface | Node,\n    glSurface: Surface\n  };\n  dependents: Array<Node | Surface> = [];\n\n  static defaultProps = {\n    index: 0\n  };\n\n  static contextTypes = {\n    glParent: PropTypes.object.isRequired,\n    glSurface: PropTypes.object.isRequired\n  };\n\n  static childContextTypes = {\n    glParent: PropTypes.object.isRequired\n  };\n\n  componentDidMount() {\n    const { uniform, index } = this.props;\n    if (uniform) {\n      const { glParent } = this.context;\n      invariant(\n        glParent instanceof Node,\n        'a <Bus uniform=\"..\" /> needs to be inside a Node'\n      );\n      glParent._addUniformBus(this, uniform, index);\n    }\n    this.redraw();\n  }\n\n  componentWillUnmount() {\n    const { uniform, index } = this.props;\n    if (uniform) {\n      const { glParent } = this.context;\n      invariant(\n        glParent instanceof Node,\n        'a <Bus uniform=\"..\" /> needs to be inside a Node'\n      );\n      glParent._removeUniformBus(this, uniform, index);\n    }\n  }\n\n  componentDidUpdate({ uniform: oldUniform, index: oldIndex }: *) {\n    const { uniform, index } = this.props;\n    if (uniform && (uniform !== oldUniform || index !== oldIndex)) {\n      const { glParent } = this.context;\n      invariant(\n        glParent instanceof Node,\n        'a <Bus uniform=\"..\" /> needs to be inside a Node'\n      );\n      if (oldUniform) glParent._removeUniformBus(this, oldUniform, oldIndex);\n      glParent._addUniformBus(this, uniform, index);\n    }\n    this.redraw();\n  }\n\n  getChildContext(): { glParent: Bus } {\n    return {\n      glParent: this\n    };\n  }\n\n  glNode: ?Node = null;\n  _addGLNodeChild(node: Node) {\n    this.glNode = node;\n    this.context.glParent.redraw();\n  }\n  _removeGLNodeChild(node: Node) {\n    this.glNode = null;\n  }\n\n  _addDependent(node: Node | Surface) {\n    const i = this.dependents.indexOf(node);\n    if (i === -1) {\n      invariantNoDependentsLoop(this, node);\n      this.dependents.push(node);\n    }\n  }\n\n  _removeDependent(node: Node | Surface) {\n    const i = this.dependents.indexOf(node);\n    if (i !== -1) this.dependents.splice(i, 1);\n  }\n\n  getGLRenderableNode(): ?Node {\n    return this.glNode;\n  }\n\n  getGLRenderableContent(): mixed {\n    const { mapRenderableContent } = this.context.glSurface;\n    const { glBusRootNode } = this;\n    return glBusRootNode && mapRenderableContent\n      ? mapRenderableContent(glBusRootNode)\n      : null;\n  }\n\n  getGLName(): string {\n    return `Bus(${\n      this.glNode\n        ? this.glNode.getGLName()\n        : String(this.getGLRenderableContent())\n    })`;\n  }\n\n  getGLShortName(): string {\n    const content = this.getGLRenderableContent();\n    const shortContentName = String(\n      (content && content.constructor && content.constructor.name) || content\n    );\n    return `Bus(${\n      this.glNode ? this.glNode.getGLShortName() : shortContentName\n    })`;\n  }\n\n  /**\n   * Capture the underlying Node pixels.\n   * NB it only works for nodes, not for content like video/canvas.\n   */\n  capture(x?: number, y?: number, w?: number, h?: number): NDArray {\n    invariant(this.glNode, \"Bus does not contain any Node\");\n    return this.glNode.capture(x, y, w, h);\n  }\n\n  glBusRootNode: ?mixed;\n  onRef = (ref: mixed) => {\n    this.glBusRootNode = ref;\n  };\n\n  /**\n   * Schedule a redraw of all nodes that depends on this Bus.\n   *\n   * @function\n   */\n  redraw = () => {\n    this.dependents.forEach(d => d.redraw());\n  };\n\n  _onContextLost() {\n    const { glNode } = this;\n    if (glNode) glNode._onContextLost();\n  }\n\n  _onContextRestored(gl: WebGLRenderingContext) {\n    const { glNode } = this;\n    if (glNode) glNode._onContextRestored(gl);\n  }\n\n  _draw = () => {\n    // FIXME: _draw() on a Bus? (would a third party need this?)\n  };\n\n  render() {\n    const { children } = this.props;\n    const {\n      glSurface: { RenderLessElement, mapRenderableContent }\n    } = this.context;\n    return (\n      <RenderLessElement ref={mapRenderableContent ? this.onRef : undefined}>\n        {typeof children === \"function\" ? children(this.redraw) : children}\n      </RenderLessElement>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}